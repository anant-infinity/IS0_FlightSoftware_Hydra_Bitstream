
#ifndef _TEST_C
	#define _TEST_C

#include "test.h"
#include "Seq_ops/main_seq.h"
#include "SPI_Flash/spi_flash.h"
#include "EPS/pwr.h"
#include "COMM_TRX_U/uhf.h"
#include "COMM_TRX_U/uhf_tx.h"
#include "COMM_TRX_U/uhf_rx_v2.h"
#include "COMM_TX_S/sband.h"
#include "CIP/cip.h"
#include "CCSDS/ccsds.h"
#include "SD_CARD/sd.h"
#include "Command_handle/command_handle.h"
#include "RTC/rtc.h"
#include "gpios.h"
#include "ADCS/adcs.h"
#include "math.h"
#include "UART/UART_RX_V3.h"
#include "UART/UART_TX.h"
#include "string.h"
#include "Utils/utils.h"
#include "I2C/i2c.h"
#include "DAXSS/daxss.h"
#include <assert.h>

#define BUFFER_A_SIZE   2

#define FLASH_MANUFACTURER_ID   (uint8_t)0x01
#define FLASH_DEVICE_ID         (uint8_t)0x17

static uint8_t g_flash_wr_buf[BUFFER_A_SIZE];
static uint8_t g_flash_rd_buf[BUFFER_A_SIZE];

void test_main_seq(){
	main_seq();
}

void test_i2c(addr_t addr){
	uint8_t rx_data;
	uint16_t const data_l = 4;uint16_t i;
	uint8_t data[data_l];
	for(i=0; i< data_l; i++){
		data[i] = i%10;
	}
	data[0] = 0x02;
	data[1] = 0x01;
	data[2] = 0x02;
	data[3] = 0x03;

	I2C_Set_Reset(addr, 0);
	I2C_Set_Reset(addr, 1);
	uint8_t stat = 6;
	stat = I2C_Set_Divider(addr, stat);
	while(1){
		data[0] = 0x02;
		statusG = I2C_Transaction(addr, data, data_l, 0);
		data[0] = 0x02;
		rx_data = I2C_Transaction(addr, data, 1, 1);
	}
}

void test_spi_characterize(){
	Init();
	uint16_t i;
	uint8_t data[512];
	uint16_t len = sizeof(data);
	for(i=0; i<len; i++){
		data[i] = i;
	}
	uint8_t curr_slave = MSS_SPI_SLAVE_0;
	MSS_GPIO_set_output( MSS_GPIO_16, 1);
	MSS_GPIO_set_output( MSS_GPIO_17, 1);

	while(1){
		PWR_Switch(GPIO_DSW0_DAXSS_Mask, 1);
		SBAND_TX_Data(data, len);
		PWR_Switch(GPIO_DSW0_DAXSS_Mask, 0);
		statusG = SD_Read_Data(Transmit_MSG[Globals.Current_Transmit.Transmit_Buffer_Index] , 512, 0x00000001, Globals.Current_SD);
	}

}
void test_transmit_handle(){
	Init();
	uint16_t len=256;
	uint32_t enables = REQ_BEACON_TRANSMIT | REQ_PARAM_TRANSMIT;
	memset(Transmit_MSG[0], 1, 512);
	memset(Transmit_MSG[1], 1, 512);
	uint8_t k[2][100];
	memset(k[0], 1, 100);
	memset(k[1], 2, 100);
	uint8_t * p1 = k[0];
	uint8_t * p2 = k[1];
	while(1){
		Globals.Indication_Flags |= enables;
		Manage_Data_Transmission();
		Handle_Transmit();
//		if(Globals.UHF_TX_Module_Sync.CMD_Seq_Count == UHF_TX_STATE_IDLE){
//			Globals.UHF_TX_Module_Sync.CMD_Seq_Count = UHF_TX_STATE_TRANSFER_DATA;
//		}
//		UHF_TX_Transmit_Data(UHF_TX_ADDR, (uint8_t *)&ax_25_pack, sizeof(ax_25_pack), &Transmit_MSG[Globals.Current_Transmit_Buffer_Index][Globals.Curr_Transmit_Offset], Globals.Current_Transmit_Length);
	}

}
void test_daxss(){
	Globals.Sat_Avoid_Mode = 0x00;
	statusG = 0;
	Globals.Indication_Flags = 0;Globals.Current_SD = MSS_SPI_SLAVE_1;
	RTC_Enable();

	#ifdef ENABLE_UART0_COMMAND
    CMD_Handle_Init();
    #endif

    Init();

	Globals.Sat_Curr_Mode = SC_SCID_MODE;
	while(1){
		//Tested on 6/28: was successful!
		//TODO: confirm operation, update Handler2 name, remove old.
		statusG = DAXSS_Seq();
		DAXSS_Response_Handler2();
	}
}

//TODO: need to implement sync packet function to start at EB 90.
void test_cip() {
	Init();
	uint16_t back = 0;
	uint16_t stat = 0;
	uint8_t mode = 0;
	uint16_t toread;
	uint16_t pack_len = 24;
	MSS_UART_init(&g_mss_uart0,MSS_UART_9600_BAUD,MSS_UART_DATA_8_BITS | MSS_UART_NO_PARITY | MSS_UART_ONE_STOP_BIT);
	uint8_t message[12] = "Hello World";
//	while(1){
	MSS_UART_polled_tx( &g_mss_uart0, message, sizeof(message) );
//	}

}

void test_UHF_TXRX_Loopback(){
	Timer16_t delay;
	delay.Time = 500;
	RTC_Enable();
	Global_Init_GPIOs();
	Flash_Init();
	UHF_init();
	CMD_Handle_Init();
	Load_Factory_Value();
	RTC_Enable();
	uint16_t len = 256;
	uint8_t data[len];uint16_t i;
	memset(data, 0x00, len);
	for(i=0; i<len; i++){
		data[i] = i%7;
	};
	i=0;
	uint8_t ax_len = sizeof(ax_25_pack);
	delay.Start = RTC_Get_Value16();
	UHF_Send_Command(UHF_TRANSMIT, 0, 0);
	while(1){

		CCSDS_AX_25_Wrap_Opp();
		if( i < 20){
			if(Globals.UHF_TX_Module_Sync.CMD_Seq_Count == UHF_TX_STATE_IDLE){
				if(Utils_Handle_Timer16_Started(&delay)){
					delay.Start = RTC_Get_Value16();
					Globals.UHF_TX_Module_Sync.CMD_Seq_Count = UHF_TX_STATE_TRANSFER_DATA;
					data[0]++;
					i++;
				}
			}
		}else{
			i=0;
		}
		statusG = UHF_TX_Transmit_Data(UHF_TX_ADDR, (uint8_t *)&ax_25_pack, ax_len, (uint8_t *)(&data), len);
		CMD_Poll_CMD();

	}
}
void test_SD_Card(){
	Global_Init_GPIOs();
	PWR_Switch(GPIO_DSW0_DAXSS_Mask, 0);
	uint8_t sig = 0;

	sig = 1;
	PWR_Switch(GPIO_DSW0_DAXSS_Mask, sig);

	Globals.Current_SD = SD_Select_Init();

	sig = 0;
	PWR_Switch(GPIO_DSW0_DAXSS_Mask, sig);
	uint16_t data_L = 512;uint64_t i;
	uint8_t w_data[data_L], r_data[data_L];
	for (i =0; i<data_L; i++){
		w_data[i]=i%9;
		r_data[i] = 0;
	}
	sig = 1;
	PWR_Switch(GPIO_DSW0_DAXSS_Mask, sig);
	i = SD_Write_Data(w_data, data_L, 4, Globals.Current_SD);
	sig = 0;
	PWR_Switch(GPIO_DSW0_DAXSS_Mask, sig);
	while(1){
		sig = 1;
		PWR_Switch(GPIO_DSW0_DAXSS_Mask, sig);
		i = SD_Read_Data(r_data, data_L, 4, Globals.Current_SD);
		sig = 0;
		PWR_Switch(GPIO_DSW0_DAXSS_Mask, sig);
		i = FLASH_Verify_write(w_data, r_data, data_L);
		if( i != data_L){
			sig = !sig;
		}
		memset(r_data, 0, data_L);
	}
}

void test_SD_Write_Packets() {
	Init();
	uint8_t beac_write_addr = Globals.Beacon_Write_Start;
	uint8_t read_data[512], j;
	uint16_t i=0,err=0;
	while(1) {
		Beacon_Timer_Handler();
		if (beac_write_addr < Globals.Beacon_Write_Start) {
			j = SD_Read_Sector(read_data, beac_write_addr, Globals.Current_SD, 512);
			if (!j) {
				j = 1;
				j = 0;
			}
			beac_write_addr = Globals.Beacon_Write_Start;
			for (i=0,err=0; i<BEACON_PACKET_SIZE; i++) {
				if (read_data[i+2] != ((uint8_t *)&Beacon_pack)[i]){
					err++;
				}
			}
			if (err > 5) {
				return;
			}
			Beacon_pack.ADCS_Body_Frame_Rate3++;
			Beacon_pack.EPS_Bat_Heater_Curr++;
		}
	}
}

void test_save_parameter_character(){
	Global_Init_GPIOs();
	Flash_Init();
	uint8_t sig2 = 0;
	while(1){
		Load_Factory_Value();
//		if(Globals.Param_Module_sync.CMD_Seq_Count == FLASH_STATE_IDLE){
//			Globals.Param_Module_sync.CMD_Seq_Count = FLASH_STATE_ERASE_CMD;
//		}
		statusG = Save_Parameter_Table();
//		statusG = Load_Parameter_Table();
		sig2 = !sig2;
		PWR_Switch(GPIO_DSW1_CIP_Mask, sig2);
		if(statusG == 0){
			continue;
		}
		if(Globals.Subsystem_Restart_Limit != 0x03){
			continue;
		}
	}
}

void test_UHF_DATA_TX(){
	UHF_init();
	CMD_Handle_Init();
	uint8_t dummy[1];
	uint16_t i, stat = 0;
	for(i = 0; i< sizeof(dummy); i++){
		dummy[i] = i%10;
	}
	while(1){
		CCSDS_AX_25_Wrap_Opp();
		statusG = UHF_TX_Transmit_Data(UHF_TX_ADDR, (uint8_t *)&ax_25_pack, sizeof(ax_25_pack), dummy, sizeof(dummy));
		CMD_Poll_CMD();
	}

}

void test_UART_RX_V3_TX_Loopback(addr_t add_rx, addr_t add_tx){

	Init();

	uint32_t i = 0;
    uint16_t stat = 0;
    uint8_t data[1000];
    uint16_t r = UART_RX3_Disable_All(add_rx);
    r = UART_RX3_Enable_All(add_rx);
	r = UART_RX3_Set_Config_Reg(add_rx, 0x01);
	stat = UART_RX3_Set_Read_Pointer(add_rx, 0x03f1);
	uint16_t toread;
	uint8_t dummy[1000];
	for(i =0; i < sizeof(dummy); i++){
		dummy[i] = i%73;
	}
	uint16_t limit = sizeof(dummy);
	uint32_t errors = 0;
	while(1){
		stat = UART_TX_send_data(add_tx, dummy, limit);
    	toread = 0;
		toread =  (UART_RX3_Get_Write_Pointer(add_rx)) % UART_RX_MAX_BUFFER_SIZE;
		stat = UART_RX3_Get_Status_Reg(add_rx);
		stat = UART_RX3_Get_Write_Reg(add_rx);
		if(toread >= limit){
			toread = toread % 4096;

			stat = UART_RX3_get_data(add_rx, data, toread);

			if(stat > 0){
				if(stat != toread){
					errors++;
					uint8_t s[] ={ (uint8_t)((stat >> 8) & 0xff) , (uint8_t)(stat & 0xff)};
					MSS_UART_polled_tx(CMD_UART, s, sizeof(stat));
				}else{
					for(i = 0; i < stat; i++){
						if(data[i] != dummy[i]){
							errors++;
							stat = 0xffff;
							uint8_t s[] ={ (uint8_t)((stat >> 8) & 0xff) , (uint8_t)(stat & 0xff)};
							MSS_UART_polled_tx(CMD_UART, s, sizeof(stat));
							break;
						}
					}
				}
				uint8_t s[] ={ (uint8_t)((stat >> 8) & 0xff) , (uint8_t)(stat & 0xff)};
				MSS_UART_polled_tx(CMD_UART, s, sizeof(stat));
				r = UART_RX3_Disable_All(add_rx);
				r = UART_RX3_Enable_All(add_rx);
				r = UART_RX3_Set_Config_Reg(add_rx, 0x01);
			}
		}
		memset(data, 0, sizeof(data));
    }
}

void test_UHF_Seq(){
	RTC_Enable();
	CMD_Handle_Init();
	UHF_init();
	Flash_Init();
	Load_Factory_Value();
	statusG = Save_Parameter_Table();
	statusG = -1;
	statusG = Load_Parameter_Table();
	Globals.Boot_Up_Counter++;
	while(1){
		if((Globals.Indication_Flags & SAVE_PARAMETER_MAP_FLAG) > 0){
			statusG = Save_Parameter_Table();
			if(statusG == 0){
				/* Unable to update the parameter table. What should we do?*/
			}
			Globals.Indication_Flags &= (~SAVE_PARAMETER_MAP_FLAG);
		}
		statusG = UHF_Seqs();
		UHF_Response_Handler();
		uint8_t dummy[] = {'G', 'O', 'T', ',', ' ', 'I', 'T'};
		MSS_UART_polled_tx(CMD_UART, dummy, sizeof(dummy));
	}
}

void test_RTC(){
	uint8_t v[] = {0x01, 0x02, 0x03, 0x04, 0x05};
	uint8_t r[] = {0x01, 0x02, 0x03, 0x04, 0x05};
	uint64_t d = 0;
	while(1){
		RTC_Get_Value_Pointer1(r);
		d = RTC_Get_Value64();
		d = RTC_Get_Value64();
		d = RTC_Get_Value64();
		d = RTC_Get_Value64();
		RTC_Get_Value_Pointer1(r);
		d = RTC_Reset();
		d = RTC_Get_Value64();
		d = RTC_Get_Value64();
		d = RTC_Get_Value64();
		RTC_Get_Value_Pointer1(r);
		RTC_Get_Value_Pointer1(r);


		d = RTC_Enable();
		d = RTC_Get_Value64();
		d = RTC_Get_Value64();
		d = RTC_Get_Value64();
		d = RTC_Get_Value64();
		RTC_Get_Value_Pointer1(r);
		RTC_Get_Value_Pointer1(r);
		RTC_Get_Value_Pointer1(r);

		d = RTC_Set_Value(v, sizeof(v));
		d = RTC_Get_Value64();
		d = RTC_Get_Value64();
		d = RTC_Get_Value64();
		RTC_Get_Value_Pointer1(r);
		RTC_Get_Value_Pointer1(r);
		RTC_Get_Value_Pointer1(r);

		d = RTC_Enable();
		RTC_Get_Value_Pointer1(r);
		d = RTC_Get_Value64();
		d = RTC_Get_Value64();
		d = RTC_Get_Value64();
		d = RTC_Get_Value64();
		RTC_Get_Value_Pointer1(r);

	}
}
void test_SBand_Seq(){
	Global_Init_GPIOs();
	Flash_Init();
	CMD_Handle_Init();

	I2C_Set_Reset(I2C_SBAND_APB_ADDR, 0);
	I2C_Set_Reset(I2C_SBAND_APB_ADDR, 1);
	uint8_t stat = 6;
	stat = I2C_Set_Divider(I2C_SBAND_APB_ADDR, stat);

	uint16_t rx_data = 50;
	statusG = Load_Parameter_Table();

	SBAND_Init_Comm();
	Globals.Sat_Curr_Mode = SC_CHARGING_MODE;
	uint8_t sig = 0;
	uint8_t s[2];
	while(1){

		if(Globals.SBand_Module_Sync.CMD_Seq_Count == SBAND_POLL_CONFIG)
			Globals.Indication_Flags &= ~TRANSMIT_DATA_READY;
		else
			Globals.Indication_Flags |= TRANSMIT_DATA_READY;

		rx_data = SBAND_I2C_Read(SBAND_BUFF_COUNT_UB, 2);
		s[0]= ((rx_data >> 8));
		s[1] = rx_data ;
		MSS_UART_polled_tx(CMD_UART, s, 2);
		SBand_Seq();
	}

}

//comment this to remove Beacon sending functionality
#define SEND_BEAC_PACK
void test_Sband_data_mode() {
	Init();
	uint8_t stat = 0;
	uint8_t ctrl_PA = 1;
	uint16_t fill_rate = 4096;
	uint16_t res;
	uint16_t size;
	// put in sync mode
	stat = 0x00;
	stat= SBAND_I2C_Write(SBAND_CONTROL, &stat, 1);
	stat = 0x81;
	stat= SBAND_I2C_Write(SBAND_CONTROL, &stat, 1);
	stat= SBAND_I2C_Read(SBAND_CONTROL, 1);
	// set scrambler to ON.
	stat = 0x00;
	stat= SBAND_I2C_Write(SBAND_ENCODER, &stat, 1);
	stat= SBAND_I2C_Read(SBAND_ENCODER, 1);
	// set power to max
	stat = 2;
	stat= SBAND_I2C_Write(SBAND_PA_POWER, &stat, 1);
	stat = SBAND_I2C_Read(SBAND_PA_POWER, 1);
	// set frequency to 2402 (0x4), something else (0xA)
	stat = 0x04;
	stat= SBAND_I2C_Write(SBAND_SYNTH_OFFSET, &stat, 1);
	stat = SBAND_I2C_Read(SBAND_SYNTH_OFFSET, 1);
	res = SBAND_I2C_Read(SBAND_PA_TEMP_UB, 2);

	uint8_t user_data[512];
	size= 512;
	memset(user_data, 0xAA,sizeof(user_data));
	uint16_t tmp = SBAND_I2C_Read(SBAND_BUFF_COUNT_UB, 2);
	while(1) {
		//turn PA off
		if (!ctrl_PA) {
			stat = 0x01;
			stat= SBAND_I2C_Write(SBAND_CONTROL, &stat, 1);
		}
		// turn PA on
		if (ctrl_PA) {
			stat = 0x82;
			stat= SBAND_I2C_Write(SBAND_CONTROL, &stat, 1);
		}

#ifdef SEND_BEAC_PACK
		Beacon_pack.CDH_Primary_Info = (Globals.Sat_Curr_Mode  & 0x07);
		Beacon_pack.CDH_Primary_Info |= (((Globals.Indication_Flags & IS_ECLIPSE) >> 4) & 0x80); /* The solar panel threshold is to be updated*/
		Beacon_pack.CDH_Primary_Info |= !(MSS_GPIO_get_outputs() & GPIO_EN_BUS_TRAN_Mask) << 4;
		Beacon_pack.CDH_Subsystem_ON_Stat = PWR_Update_SW_Data();
		Beacon_pack.CDH_Last_CMD_APID = Globals.Last_CMD_Rec.apid;
		Beacon_pack.CDH_Last_CMD_Option1 = Globals.Last_CMD_Rec.option1;
		Beacon_pack.CDH_Last_CMD_Option2 = Globals.Last_CMD_Rec.option2;

		Beacon_pack.CDH_Indication_Flags = Globals.Indication_Flags;

		Beacon_pack.CDH_ADCS_Read_start = Globals.ADCS_Read_Start;
		Beacon_pack.CDH_Beacon_Read_start = Globals.Beacon_Read_Start;
		Beacon_pack.CDH_HK_Read_start = Globals.HK_Read_Start;
		Beacon_pack.CDH_Log_Read_start = Globals.Log_Read_Start;
		Beacon_pack.CDH_SciC_Read_start = Globals.SciC_Read_Start;
		Beacon_pack.CDH_SciD_Read_start = Globals.SciD_Read_Start;

		Beacon_pack.CDH_ADCS_Write_start = Globals.ADCS_Write_Start;
		Beacon_pack.CDH_Beacon_Write_start = Globals.Beacon_Write_Start;
		Beacon_pack.CDH_HK_Write_start = Globals.HK_Write_Start;
		Beacon_pack.CDH_Log_Write_start = Globals.Log_Write_Start;
		Beacon_pack.CDH_SciC_Write_start = Globals.SciC_Write_Start;
		Beacon_pack.CDH_SciD_Write_start = Globals.SciD_Write_Start;


		// Update packet count
		Globals.Beacon_Packet_Seq_Counter++;


		uint32_t Curr = RTC_Get_Value32();
		/* Taking care of timer overflow */
		if (Curr < Globals.Last_Command_Timer.Start){
			Curr += (0xffffffff - Globals.Last_Command_Timer.Start);
		}else{
			Curr -= Globals.Last_Command_Timer.Start;
		}
		Beacon_pack.CDH_Last_CMD_Timer = Curr;

//		uint8_t * ptr = (uint8_t *) &Beacon_pack;
//		// FOR GAIL: Set Beacon Packet to dummy count
//		for (int i = 0; i < sizeof(Beacon_pack)-2; i++) {
//			ptr[i] = i;
//		}


		CCSDS_Pack( BEACON_PACKET_APID, 0xC0, Globals.Beacon_Packet_Seq_Counter, (struct CCSDS_Header *)&(Beacon_pack.beac_head), sizeof(Beacon_pack));
		CCSDS_Fletcher_16((uint8_t *)(&Beacon_pack), sizeof(Beacon_pack) - 2);
		uint16_t sync = SBAND_SYNC_WORD;
		memcpy(user_data, (uint8_t* ) &sync, SIZEOF_SYNC_WORD);
		memcpy(&user_data[SIZEOF_SYNC_WORD], (uint8_t*)&Beacon_pack, sizeof(Beacon_pack)+SIZEOF_SYNC_WORD);
		size = sizeof(Beacon_pack)+SIZEOF_SYNC_WORD;
#endif

		stat= SBAND_I2C_Read(SBAND_CONTROL, 1);
//		tmp = SBAND_I2C_Read(SBAND_TRAN_READY, 1);
		tmp = SBAND_I2C_Read(SBAND_BUFF_COUNT_UB, 2);
		if (tmp <= (SBAND_BUFFER_SIZE - size)) {
//			stat = 0x81;
//			stat= SBAND_I2C_Write(SBAND_CONTROL, &stat, 1);
			SBAND_TX_Data(user_data, size);
			tmp = SBAND_I2C_Read(SBAND_BUFF_COUNT_UB, 2);
//			stat = 0x82;
//			stat= SBAND_I2C_Write(SBAND_CONTROL, &stat, 1);
		}
		else {
			stat = 0x82;
			SBAND_I2C_Write(SBAND_CONTROL, &stat, 1);
		}
	}

}

void test_Sband_OneAtATime(void) {
	uint16_t sync = SBAND_SYNC_WORD,res;
	uint8_t * beac_ptr = (uint8_t *)&Beacon_pack;
	uint8_t dum_beac[sizeof(Beacon_pack) + SIZEOF_SYNC_WORD];
	SBAND_SET_MODE(CONFIG);
	CONFIG_SBAND(DB28, MHZ2402);

	memcpy(dum_beac, (uint8_t*)&sync, SIZEOF_SYNC_WORD);
	for (res=2; res < sizeof(Beacon_pack) + SIZEOF_SYNC_WORD; res++) {
		dum_beac[res] = beac_ptr[res-2];
	}

	while(1) {

	}



}

//Straight from user manual
void test_Sband_Continuous(void) {

	Init();
	uint8_t stat = 0;
	uint8_t ctrl = 1;
	uint16_t res, tmp;
	uint16_t size = sizeof(Beacon_pack) + SIZEOF_SYNC_WORD, sync=SBAND_SYNC_WORD;
	uint8_t user_data[4096];
	uint8_t dum_beac[size];
	uint8_t * beac_ptr = (uint8_t* )&Beacon_pack;

	// reset buffer, under/overflow counts
	stat = 0x00;
	stat= SBAND_I2C_Write(SBAND_CONTROL, &stat, 1);

	//set power to 28dB
	stat = 0x2;
	stat= SBAND_I2C_Write(SBAND_PA_POWER, &stat, 1);

	//confirm empty buffer
	tmp = SBAND_I2C_Read(SBAND_BUFF_COUNT_UB, 2);
	if (tmp) {
		return;
	}
	//put in sync mode
	stat = 0x01;
	stat= SBAND_I2C_Write(SBAND_CONTROL, &stat, 1);

	// Update Beacon Packet
	Globals.Beacon_Packet_Seq_Counter++;
	CCSDS_Pack( BEACON_PACKET_APID, 0xC0, Globals.Beacon_Packet_Seq_Counter, (struct CCSDS_Header *)&(Beacon_pack.beac_head), sizeof(Beacon_pack));
	CCSDS_Fletcher_16((uint8_t *)(&Beacon_pack), sizeof(Beacon_pack) - 2);

	memcpy(dum_beac, (uint8_t*)&sync, SIZEOF_SYNC_WORD);
	for (res=2; res < sizeof(Beacon_pack) + SIZEOF_SYNC_WORD; res++) {
		dum_beac[res] = beac_ptr[res-2];
	}

	// fill user_data
	for (res = 0; res < SBAND_BUFFER_SIZE; res++) {
		user_data[res] = dum_beac[res];
	}
	//User_data is now 16 identical beac_packs with sync word

	//write data
	SBAND_TX_Data(user_data, SBAND_BUFFER_SIZE);
	//confirm buffer filled
	tmp = SBAND_I2C_Read(SBAND_BUFF_COUNT_UB, 2);
	if (tmp != SBAND_BUFFER_SIZE) {
		return;
	}
	//confirm no overflow
	tmp = SBAND_I2C_Read(SBAND_BUF_OVRUN_UB, 2);
	if (tmp) {
		return;
	}

	//put in sync mode
	stat = 0x81;
	stat= SBAND_I2C_Write(SBAND_CONTROL, &stat, 1);
	//put in data mode
	stat = 0x82;
	stat= SBAND_I2C_Write(SBAND_CONTROL, &stat, 1);

	//start timer. set for 5 seconds
	uint16_t start = RTC_Get_Value16();
	uint16_t duration = 5000;
	while(RTC_Get_Value16()  - start < duration) {
		// wait until there is space available
		while(!(SBAND_I2C_Read(SBAND_TRAN_READY, 1)));
		/*ATTEMPT #1; fill packets until no more left. This most likely takes too long and we underflow*/
		//fill as much as we can
//		while(SBAND_I2C_Read(SBAND_BUFF_COUNT_UB, 2) < (SBAND_BUFFER_SIZE - size) ){
//			SBAND_TX_Data(user_data, size);
//		}

		/** ATTEMPT #2: just fill one packet of 256 */

		SBAND_TX_Data(dum_beac, size);

		/* ATTEMPT #3: Fill 4096-513=3583 bytes in one go,
		 * */
//		SBAND_TX_Data(user_data, SBAND_BUFFER_SIZE - SBAND_TRAN_READY_THRESH);
	}
	//
	while(!(SBAND_I2C_Read(SBAND_TRAN_READY, 1)));

	//put in sync mode
	stat = 0x1;
	stat= SBAND_I2C_Write(SBAND_CONTROL, &stat, 1);

	//confirm
	tmp = SBAND_I2C_Read(SBAND_BUFF_COUNT_UB, 2);
	if (tmp > SBAND_TRAN_READY_THRESH) {
		return;
	}

	//confirm no overflow
	tmp = SBAND_I2C_Read(SBAND_BUF_OVRUN_UB, 2);
	if (tmp) {
		return;
	}
	//confirm no underflow
	tmp = SBAND_I2C_Read(SBAND_BUF_UNRUN_UB, 2);
	if (tmp) {
		return;
	}

	//put in config mode
	stat = 0x0;
	stat= SBAND_I2C_Write(SBAND_CONTROL, &stat, 1);

	return;

}

void test_Sband_Counter(){
	Init();

//	I2C_Set_Reset(I2C_APB_ADDR, 0);
//	I2C_Set_Reset(I2C_APB_ADDR, 1);
	uint8_t stat = 6;
//	stat = I2C_Set_Divider(I2C_APB_ADDR, stat);
	uint16_t res = 0;

	while(1){
		stat = 0;
		stat= SBAND_I2C_Write(SBAND_CONTROL, &stat, 1);
		stat= SBAND_I2C_Read(SBAND_CONTROL, 1);
		stat = 0x10;
		stat= SBAND_I2C_Write(SBAND_ENCODER, &stat, 1);
		stat= SBAND_I2C_Read(SBAND_ENCODER, 1);
		stat = 3;
		stat= SBAND_I2C_Write(SBAND_PA_POWER, &stat, 1);
		stat = SBAND_I2C_Read(SBAND_PA_POWER, 1);
		stat = 0x4;
		stat= SBAND_I2C_Write(SBAND_SYNTH_OFFSET, &stat, 1);
		stat = SBAND_I2C_Read(SBAND_SYNTH_OFFSET, 1);
		res = SBAND_I2C_Read(SBAND_PA_TEMP_UB, 2);
	}
}
void test_SBand_SPI(){
	Global_Init_GPIOs();
	Flash_Init();

	I2C_Set_Reset(I2C_SBAND_APB_ADDR, 0);
	I2C_Set_Reset(I2C_SBAND_APB_ADDR, 1);
	uint8_t stat = 50;
	stat = I2C_Set_Divider(I2C_SBAND_APB_ADDR, stat);

	uint16_t rx_data = 50;
	statusG = Load_Parameter_Table();

	SBAND_Init_Comm();


	uint16_t const data_l = 2048;uint16_t i;
	uint8_t data[data_l];
	for(i=0; i< data_l; i++){
		data[i] = i%10;
	}
	stat = 0;
	stat= SBAND_I2C_Write(SBAND_CONTROL, &stat, 1);
	stat= SBAND_I2C_Read(SBAND_CONTROL, 1);
	stat = 0x01;
	stat= SBAND_I2C_Write(SBAND_CONTROL, &stat, 1);
	stat= SBAND_I2C_Read(SBAND_CONTROL, 1);

	while(1){
		rx_data = SBAND_I2C_Read(SBAND_BUFF_COUNT_UB, 2);
		rx_data  = SBAND_I2C_Read(SBAND_BUF_UNRUN_LB, 2);
		rx_data  = SBAND_I2C_Read(SBAND_BUF_OVRUN_LB, 2);
		SBAND_TX_Data(data, data_l);
		rx_data = SBAND_I2C_Read(SBAND_BUFF_COUNT_UB, 2);
		rx_data  = SBAND_I2C_Read(SBAND_BUF_UNRUN_LB, 2);
		rx_data = SBAND_I2C_Read(SBAND_BUF_OVRUN_LB, 2);
	}
}

void test_i2c_sband(){

	Global_Init_GPIOs();

	I2C_Set_Reset(I2C_SBAND_APB_ADDR, 0);
	I2C_Set_Reset(I2C_SBAND_APB_ADDR, 1);
	uint8_t stat;

	uint16_t rx_data = 50;
	while(1){
		rx_data = 50;
 		rx_data = I2C_Set_Divider(I2C_SBAND_APB_ADDR, (uint8_t)rx_data);
//		SBAND_Fill_Packets();
		rx_data = SBAND_I2C_Read(SBAND_SYNTH_OFFSET, 1);
		rx_data = SBAND_I2C_Read(SBAND_CONTROL, 1);
		rx_data = SBAND_I2C_Read(SBAND_RESET, 1);
		rx_data = SBAND_I2C_Read(SBAND_FIRM_VER, 1);
		rx_data = SBAND_I2C_Read(SBAND_TRAN_READY, 1);
		rx_data = SBAND_I2C_Read(SBAND_BUFF_COUNT_UB, 1);
		rx_data = SBAND_I2C_Read(SBAND_BUFF_COUNT_LB, 1);
		rx_data = SBAND_I2C_Read(SBAND_BUF_UNRUN_UB, 1);
		rx_data = SBAND_I2C_Read(SBAND_BUF_UNRUN_LB, 1);
		rx_data = SBAND_I2C_Read(SBAND_BUF_OVRUN_UB, 1);
		rx_data = SBAND_I2C_Read(SBAND_BUF_OVRUN_LB, 1);
		rx_data = SBAND_I2C_Read(SBAND_BAT_CUR_UB, 1);
		rx_data = SBAND_I2C_Read(SBAND_BAT_CUR_LB, 1);
		rx_data = SBAND_I2C_Read(SBAND_BAT_VOL_UB, 1);
		rx_data = SBAND_I2C_Read(SBAND_BAT_VOL_LB, 1);
		rx_data = SBAND_I2C_Read(SBAND_BAT_VOL_UB, 2);
	}

}
uint8_t sig1 = 0;
void test_i2c_eps() {
	Global_Init_GPIOs();

	uint8_t stat;
	PWR_Init_Comm();
	while(1) {
		PWR_Switch(GPIO_DSW0_DAXSS_Mask, sig1);
		sig1 = !sig1;
		Read_EPS_Data();
	}
}

void check_cmd_reception(){
    CMD_Handle_Init();
    statusG = UHF_init();
    uint16_t data_L = 512, i=0;
    uint8_t data[data_L];
    uint8_t rx_data[data_L];
    uint64_t temp=0;
    for (i =0; i<data_L; i++){
        data[i]=i%5;
        rx_data[i] = 0;
    }
    data[0] = 0xff;
    statusG = UHF_RX_Reset_Module(UHF_RX_ADDR);
    statusG = 0xff;
    while(1){
        statusG = CMD_Pool_For_UART0_CMD();
        CCSDS_AX_25_Wrap_Opp();
        statusG = UHF_TX_Transmit_Data(UHF_TX_ADDR, (uint8_t *)&ax_25_pack, sizeof(ax_25_pack.DES_A), (uint8_t *)&(data), 20);
        statusG = CMD_Poll_CMD();
        temp = RTC_Get_Value64();
        temp = RTC_Set_Value(rx_data, 5);
        temp = RTC_Get_Value64();
    }
}

void spi_flash_test2(){
    volatile uint32_t errors = 0;
    uint32_t address = 0;
    uint16_t loop_count;

    for(loop_count = 0; loop_count < (BUFFER_A_SIZE/2); loop_count++)
    {
        g_flash_wr_buf[loop_count] = 0+loop_count;
        g_flash_rd_buf[loop_count] = 0x00;
    }
    for(loop_count = (BUFFER_A_SIZE/2); loop_count < BUFFER_A_SIZE; loop_count++)
    {
        g_flash_wr_buf[loop_count] = 0x33;
        g_flash_rd_buf[loop_count] = 0x00;
    }
    Flash_Init();

    while(1){
        uint8_t res[10];
        uint8_t cmd[10];

        MSS_SPI_set_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
        Flash_Write_EN_DIS(FLASH_WREN);
        MSS_SPI_clear_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );

        cmd[0] = FLASH_RDSR1;
        Flash_CMD(cmd, 1, res, 1);

        uint8_t res2 = Flash_Read_Status_Register_1();
        res2 = Flash_Read_Status_Register_1();

        MSS_SPI_set_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
        Flash_Write_EN_DIS(FLASH_WRDI);
        MSS_SPI_clear_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );

        res2 = Flash_Read_Status_Register_1();
        res2 = Flash_Read_Status_Register_1();



//      cmd[0] = FLASH_WRR;cmd[1] = 0;
//      Flash_CMD(cmd, 2, 0,0,0);

        Flash_CMD(cmd, 1, res, 1);
        cmd[0] = FLASH_RDSR2;
        Flash_CMD(cmd, 1, res, 1);
        cmd[0] = FLASH_RDCR1;
        Flash_CMD(cmd, 1, res, 1);

        cmd[0] = FLASH_READ_ID; cmd[1] = 0; cmd[2] = 0; cmd[3] = 0; cmd[4] = 0;
        Flash_CMD(cmd, 5, res, 2);


        address = 0x00020000;
        uint32_t stat = Flash_Erase(FLASH_SE, address);
        uint8_t p;
        cmd[0] = FLASH_RDSR1;
//      while(1){
            MSS_GPIO_set_output(MSS_GPIO_1, 1);

            Flash_CMD(cmd, 1, res, 1);
//          p = Flash_CMD_Read();
//          MSS_SPI_set_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
//          p=FLASH_get_status();
//          MSS_SPI_clear_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
//          Flash_Read_Data(0x00020000, g_flash_rd_buf, sizeof(g_flash_wr_buf));
            MSS_GPIO_set_output(MSS_GPIO_1, 0);
//      }

        address = 0x00030000;
        stat = Flash_Erase(FLASH_SE, address);
        Flash_Read_Data(0x00030000, g_flash_rd_buf, sizeof(g_flash_wr_buf));
        address = 0x00040000;
        stat = Flash_Erase(FLASH_SE, address);
        Flash_Read_Data(0x00040000, g_flash_rd_buf, sizeof(g_flash_wr_buf));

        address = 0x00020000;
        Flash_Program(address, g_flash_wr_buf, sizeof(g_flash_wr_buf));
        Flash_Read_Data(address, g_flash_rd_buf, sizeof(g_flash_wr_buf));
        errors = FLASH_Verify_write(g_flash_rd_buf, g_flash_wr_buf, sizeof(g_flash_wr_buf));

        address = 0x00030000;
        Flash_Program(address, g_flash_wr_buf, sizeof(g_flash_wr_buf));
        Flash_Read_Data(address, g_flash_rd_buf, sizeof(g_flash_wr_buf));
        errors = FLASH_Verify_write(g_flash_rd_buf, g_flash_wr_buf, sizeof(g_flash_wr_buf));

        address = 0x00040000;
        Flash_Program(address, g_flash_wr_buf, sizeof(g_flash_wr_buf));
        Flash_Read_Data(address, g_flash_rd_buf, sizeof(g_flash_wr_buf));
        errors = FLASH_Verify_write(g_flash_rd_buf, g_flash_wr_buf, sizeof(g_flash_wr_buf));

        address= 0x00030000;
        Flash_Erase(FLASH_SE, address);
        Flash_Read_Data(address, g_flash_rd_buf, sizeof(g_flash_wr_buf));

        address= 0x00020000;
        Flash_Read_Data(address, g_flash_rd_buf, sizeof(g_flash_wr_buf));
        errors = FLASH_Verify_write(g_flash_rd_buf, g_flash_wr_buf, sizeof(g_flash_wr_buf));

        address= 0x00030000;
        Flash_Read_Data(address, g_flash_rd_buf, sizeof(g_flash_wr_buf));
        errors = FLASH_Verify_write(g_flash_rd_buf, g_flash_wr_buf, sizeof(g_flash_wr_buf));

        address= 0x00040000;
        Flash_Read_Data(address, g_flash_rd_buf, sizeof(g_flash_wr_buf));
        errors = FLASH_Verify_write(g_flash_rd_buf, g_flash_wr_buf, sizeof(g_flash_wr_buf));


    }

}


void test_ADCS(){
    // Wheel IDLE command
	RTC_Enable();
	CMD_Handle_Init();

	Flash_Init();
//	Load_Factory_Value();
	statusG = -1;
	statusG = Load_Parameter_Table();
	ADCS_init();
	uint8_t tx_data[] = {0x00, 0x00};
	ADCS_Send_Command(0x07, 0x02, tx_data, 2);    /* Sending the command to turn off the wheels */

	tx_data[1] = 0x02;
	ADCS_Send_Command(0x07, 0x02, tx_data, 2);    /* Sending the command to put the wheels in external mode*/

	uint8_t tx_data_speed[] = {0x00, 0x13, 0x88, 0x13, 0x88, 0x13, 0x88, 0x13, 0x88};
	ADCS_Send_Command(0x07, 10, tx_data_speed, sizeof(tx_data_speed));    /* Sending the command to put the wheels at 50 rpm*/

	uint8_t tx_data_mag_use[] = {0x01};
	ADCS_Send_Command(12, 4, tx_data_mag_use, sizeof(tx_data_mag_use));    /* Sending the command to set the XACT to use mag 1*/
//	statusG = Save_Parameter_Table();

	Globals.Boot_Up_Counter++;
	Globals.Sat_Curr_Mode = 1;
	uint16_t addr = 0x422;
	uint8_t rx_data[400];
	uint16_t len = 1;
	uint8_t tx_data_torque_rods[] = {0x00, 0x00};
	while(1){
//		if((Globals.Indication_Flags & SAVE_PARAMETER_MAP_FLAG) > 0){
//			statusG = Save_Parameter_Table();
//			if(statusG == 0){
//				/* Unable to update the parameter table. What should we do?*/
//			}
//			Globals.Indication_Flags &= (~SAVE_PARAMETER_MAP_FLAG);
//		}
		ADCS_Send_Command(10, 1, tx_data_torque_rods, sizeof(tx_data_torque_rods));
		statusG = Save_Parameter_Table();
		statusG = ADCS_Read_Data(addr, len);
		uint16_t toread = UART_RX3_Get_Write_Pointer(ADCS_UART_RX3_ADDR) % UART_RX_MAX_BUFFER_SIZE;
		toread = UART_RX3_get_data(ADCS_UART_RX3_ADDR, rx_data, toread);

		toread = ADCS_Test_CRC(rx_data, toread);
		if(!toread){
			ADCS_FDRI();
		}

//		statusG = ADCS_Seqs();
//		ADCS_Response_Handler();
	}
}

#endif
