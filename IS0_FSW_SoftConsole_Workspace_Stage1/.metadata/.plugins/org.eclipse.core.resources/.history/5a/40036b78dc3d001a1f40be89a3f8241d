
#ifndef _TEST_C
	#define _TEST_C

#include "test.h"
#include "Seq_ops/main_seq.h"
#include "SPI_Flash/spi_flash.h"
#include "../mss_spi/mss_spi.h"
#include "EPS/eps.h"
#include "COMM_TRX_U/uhf.h"
#include "COMM_TRX_U/uhf_tx.h"
#include "COMM_TRX_U/uhf_rx_v2.h"
#include "COMM_TX_S/sband.h"
#include "CIP/cip.h"
#include "CCSDS/ccsds.h"
#include "SD_CARD/sd.h"
#include "Command_handle/command_handle.h"
#include "RTC/rtc.h"
#include "gpios.h"
#include "ADCS/adcs.h"
#include "math.h"
#include "UART/UART_RX_V3.h"
#include "UART/UART_TX.h"
#include "string.h"
#include "Utils/utils.h"
#include "I2C/i2c.h"
#include "DAXSS/daxss.h"
#include <assert.h>
#include "../../t1_hw_platform.h"



#define BUFFER_A_SIZE   2

#define FLASH_MANUFACTURER_ID   (uint8_t)0x01
#define FLASH_DEVICE_ID         (uint8_t)0x17

static uint8_t g_flash_wr_buf[BUFFER_A_SIZE];
static uint8_t g_flash_rd_buf[BUFFER_A_SIZE];


//********************************** Added for EPS Testing  ********************************************\\
//Read the EPS Slaves to get the HK data

	/*------------------------------------------------------------------------------
	 * Register based address info for three EPS CoreI2C peripherals
	 */
	#define COREI2C_0                     I_EPS_I2C_C_0			//I2C Critical Channel 0
	#define COREI2C_1                     J_EPS_I2C_C_1			//I2C Critical Channel 1
	#define COREI2C_2					  K_EPS_I2C_NC			//I2C Non-Critical Channel

	/*------------------------------------------------------------------------------
	 * Register based address info for Sensor Board CoreI2C peripheral
	 */
	#define COREI2C_3					  L_SENSOR_BOARD_I2C_0	//I2C for Sensor Board

	/*------------------------------------------------------------------------------
	 * Instance data for our CoreI2C devices
	 */
	i2c_instance_t g_core_i2c0;				// Core I2C for EPS_C0;
	i2c_instance_t g_core_i2c1; 			// Core I2C for EPS_C1;
	i2c_instance_t g_core_i2c2; 			// Core I2C for EPS_NC;
	i2c_instance_t g_core_i2c3; 			// Core I2C for SENSOR_0;


	/*-----------------------------------------------------------------------------
	 *  Slave Addresses of sensor board - on coreI2C 3
	 */

	#define	SENSOR_MASTER 				((uint8_t)0x49)	// Master sensor in the triad
	#define SENSOR_VML		 			((uint8_t)0x10)	// UV spectral sensor
	/*-----------------------------------------------------------------------------
	 * All Slave Addresses of the I2C Critical Channel 0 EPS Slaves
	 */

	#define	EPS_FG1_SLAVE_C0				((uint8_t)0x36)	// 0 0110110 -> Battery Gauge Slave (U12) on EPS I2C Critical Channel 0
	#define EPS_VC1_SLAVE_C0 				((uint8_t)0x40)	// 0 1000000 -> VC Sensor (U6) on EPS I2C Critical Channel 0 -> CH1 Contains Nothing, CH2 Contains DAXSS, CH3 Contains CDH
	#define EPS_VC2_SLAVE_C0 				((uint8_t)0x43)	// 0 1000011 -> VC Sensor (U15) on EPS I2C Critical Channel 0 -> CH1 Contains SBAND, CH2 Contains UHF, CH3 Contains Battery Heater
	#define EPS_VC3_SLAVE_C0 				((uint8_t)0x41)	// 0 1000001 -> VC Sensor (U1) on EPS I2C Critical Channel 0 -> CH1 Contains PV2, CH2 Contains Nothing, CH3 Contains PV1
	#define EPS_VC4_SLAVE_C0 				((uint8_t)0x42)	// 0 1000010 -> VC Sensor (U16) on EPS I2C Critical Channel 0 -> CH1 Contains PV0

	/*-----------------------------------------------------------------------------
	 * All Slave Addresses of the I2C Critical Channel 1 EPS Slaves
	 */

	#define	EPS_FG2_SLAVE_C1				((uint8_t)0x36)	// 0 0110110 -> Battery Gauge Slave	(U13) I2C Critical Channel 1
	#define EPS_VC5_SLAVE_C1 				((uint8_t)0x40)	// 0 1000000 -> VC Sensor (U7) on EPS I2C Critical Channel 1 -> CH1 Contains GPS_12V_2 , CH2 Contains GPS_12V_1, CH3 Contains Battery Sense
	#define EPS_VC6_SLAVE_C1 				((uint8_t)0x41)	// 0 1000001 -> VC Sensor (U2) on EPS I2C Critical Channel 1 -> CH1 Contains ADCS, CH2 Contains GPS3V3, CH3 Contains CIP
	#define EPS_ADC_SLAVE_C1				((uint8_t)0x20)	// 0 0100000 -> ADC slave (U8) on EPS I2C Critical Channel 1
	/*-----------------------------------------------------------------------------
	 * All Slave Addresses of the I2C Non-Critical Channel 0 EPS Slaves
	 */

	#define	EPS_FG3_SLAVE_NC				((uint8_t)0x36)	// 0 0110110 -> Battery Gauge Slave	(U11) I2C Critical Channel 1

	/*-----------------------------------------------------------------------------
	 * Defining the Register Map of the VC Sensors - Shunt Voltage Indicates Current
	 */
	#define	Read_Manufacture_ID				((uint8_t)0xFE)		// Reading the Manufacturer ID of the IC - should be 0x5449- Works!
	#define Read_Config_Register 			((uint8_t)0x00)		// Reading default value of the configuration register
	#define	EPS_VC_CH1_SHUNT_VOLTAGE		((uint8_t)0x01)		// 16 bits Channel 1 Shunt Voltage reading;	Ops -> R
	#define	EPS_VC_CH1_BUS_VOLTAGE			((uint8_t)0x02)		// 16 bits Channel 1 Bus Voltage reading;	Ops -> R
	#define	EPS_VC_CH2_SHUNT_VOLTAGE		((uint8_t)0x03)		// 16 bits Channel 2 Shunt Voltage reading;	Ops -> R
	#define	EPS_VC_CH2_BUS_VOLTAGE			((uint8_t)0x04)		// 16 bits Channel 2 Bus Voltage reading;	Ops -> R
	#define	EPS_VC_CH3_SHUNT_VOLTAGE		((uint8_t)0x05)		// 16 bits Channel 3 Shunt Voltage reading;	Ops -> R
	#define	EPS_VC_CH3_BUS_VOLTAGE			((uint8_t)0x06)		// 16 bits Channel 3 Bus Voltage reading;	Ops -> R

	/*-----------------------------------------------------------------------------
	 * Defining the Register Map of the Fuel Gauges
	 */

	#define	EPS_FG_VCELL		((uint8_t)0x02)		// 16 bits Voltage of Cell reading;			OPs -> R
	#define	EPS_FG_SOC			((uint8_t)0x04)		// 16 bits State of Charge reading;	Ops -> R
	#define	EPS_FG_MODE			((uint8_t)0x06)		// 16 bits Mode Determination Register;	Ops -> Wnot
	#define	EPS_FG_VERSION		((uint8_t)0x08)		// 16 bits Version of IC;	Ops -> R
	#define	EPS_FG_HIBRT		((uint8_t)0x0A)		// 16 bits Hibernate entering and exiting thresholds register;	Ops -> R/Wnot
	#define	EPS_FG_CONFIG		((uint8_t)0x0C)		// 16 bits Configuration register.	Ops -> R/Wnot
	#define	EPS_FG_VALRT		((uint8_t)0x14)		// 16 bits Configures the VCELL range outside of which alerts are generated;Ops -> R/Wnot
	#define	EPS_FG_CRATE		((uint8_t)0x16)		// 16 bits Approximate charge or discharge rate of the battery; Ops -> R
	#define	EPS_FG_VRESET_ID	((uint8_t)0x18)		// 16 bits Configures VCELL threshold below which the IC resets itself; Ops->R/Wnot
	#define	EPS_FG_STATUS		((uint8_t)0x1A)		// 16 bits Indicates overvoltage, undervoltage, SOC change, SOC low, and reset alerts; Ops->R


	/***************************************************************************
	 *
	 * Defining Register Map for ADC
	 */
	#define	EPS_ADC_CONV_RES			((uint8_t)0x00)		// 16 bits
	#define	EPS_ADC_ALRT				((uint8_t)0x01)		// 16 bits
	#define	EPS_ADC_CONFIG				((uint8_t)0x02)		// 16 bits
	#define	EPS_ADC_CYC_TIME			((uint8_t)0x03)		// 16 bits
	#define	EPS_ADC_DATA_LOW_CH1		((uint8_t)0x04)		// 16 bits
	#define	EPS_ADC_DATA_HIGH_CH1		((uint8_t)0x05)		// 16 bits
	#define	EPS_ADC_DATA_HYS_CH1		((uint8_t)0x06)		// 16 bits
	#define	EPS_ADC_DATA_LOW_CH2		((uint8_t)0x07)		// 16 bits
	#define	EPS_ADC_DATA_HIGH_CH2		((uint8_t)0x08)		// 16 bits
	#define	EPS_ADC_DATA_HYS_CH2		((uint8_t)0x09)		// 16 bits
	#define	EPS_ADC_DATA_LOW_CH3		((uint8_t)0x0A)		// 16 bits
	#define	EPS_ADC_DATA_HIGH_CH3		((uint8_t)0x0B)		// 16 bits
	#define	EPS_ADC_DATA_HYS_CH3		((uint8_t)0x0C)		// 16 bits
	#define	EPS_ADC_DATA_LOW_CH4		((uint8_t)0x0D)		// 16 bits
	#define	EPS_ADC_DATA_HIGH_CH4		((uint8_t)0x0E)		// 16 bits
	#define	EPS_ADC_DATA_HYS_CH4		((uint8_t)0x0F)		// 16 bits

	// Masks for Mode 2 of ADC should be masked to pointer register.
	#define EPS_ADC_MASK_MODE2_CH1		((uint8_t)0x80)	// 1000-0000 Select CH1 in command mode
	#define EPS_ADC_MASK_MODE2_CH2		((uint8_t)0x90)	// 1001-0000 Select CH2 in command mode
	#define EPS_ADC_MASK_MODE2_CH3		((uint8_t)0xA0)	// 1010-0000 Select CH3 in command mode
	#define EPS_ADC_MASK_MODE2_CH4		((uint8_t)0xB0)	// 1011-0000 Select CH4 in command mode
	#define EPS_ADC_MASK_MODE2_CH5		((uint8_t)0xC0)	// 1100-0000 Select CH5 in command mode
	#define EPS_ADC_MASK_MODE2_CH6		((uint8_t)0xD0)	// 1101-0000 Select CH6 in command mode - Contains Thermistor on the OBC
	#define EPS_ADC_MASK_MODE2_CH7		((uint8_t)0xE0)	// 1110-0000 Select CH7 in command mode
	#define EPS_ADC_MASK_MODE2_CH8		((uint8_t)0xF0)	// 1111-0000 Select CH8 in command mode - Contains Thermistor on the Adapter Board
	#define EPS_ADC_MASK_MODE2_SEQCH	((uint8_t)0x70)	// Sequence of channels selected in configuration register
	/***************************************************************************/

	/*-----------------------------------------------------------------------------
	 * Defining the Register Map of the VEML6075
	 */

	#define	SENSOR_VEML_UV_CONF			((uint8_t)0x00)		// 16 bits UV Configuration register; OPs -> R/W - Not used currently
	#define	SENSOR_VEML_UVA_Data		((uint8_t)0x07)		// 16 bits UVA Data; OPs -> R
	#define	SENSOR_VEML_UVB_Data		((uint8_t)0x09)		// 16 bits UVB Data;	Ops -> R
	#define	SENSOR_VEML_UVCOMP1_Data	((uint8_t)0x0A)		// 16 bits UVCOMP1_Data;	Ops -> R
	#define	SENSOR_VEML_UVCOMP2_Data	((uint8_t)0x0B)		// 16 bits UVCOMP2_Data;	Ops -> R
	#define	SENSOR_DEVICE_ID			((uint8_t)0x0C)		// 16 bits Device ID;	Ops -> R

	/*-----------------------------------------------------------------------------
	 * Defining the Register Map of the AS72651
	 */

	#define	SENSOR_AS72651_STATUS_REG	((uint8_t)0x00)		// 8  bit Status Register; OPs ->
	#define	SENSOR_AS72651_WRITE_REG	((uint8_t)0x01)		// 8  bit Status Register; OPs ->
	#define	SENSOR_AS72651_READ_REG		((uint8_t)0x02)		// 8  bit Status Register; OPs ->

	#define I2C_AS72651_SLAVE_TX_VALID 	((uint8_t)0x02)
	#define I2C_AS72651_SLAVE_RX_VALID 	((uint8_t)0x01)

	/*-----------------------------------------------------------------------------
	 * Defining the virtual Register Map of the AS72651
	 */

	//Hardware and Software Version
	#define	SENSOR_AS72651_HWVERSION_H	((uint8_t)0x00)		// 8  bit Hardware Version H Register; OPs ->R
	#define	SENSOR_AS72651_HWVERSION_L	((uint8_t)0x01)		// 8  bit Hardware Version L Register; OPs ->R
	#define	SENSOR_AS72651_SWVERSION_H	((uint8_t)0x02)		// 8  bit Software Version H Register; OPs ->R
	#define	SENSOR_AS72651_SWVERSION_L	((uint8_t)0x03)		// 8  bit Software Version L Register; OPs ->R

	//Raw Data registers
	#define	SENSOR_AS72651_RAW_RGA_H	((uint8_t)0x08)		// 8  bit RAW Value H Register; OPs ->R
	#define	SENSOR_AS72651_RAW_RGA_L	((uint8_t)0x09)		// 8  bit RAW Value L Register; OPs ->R
	#define	SENSOR_AS72651_RAW_SHB_H	((uint8_t)0x0A)		// 8  bit RAW Value H Register; OPs ->R
	#define	SENSOR_AS72651_RAW_SHB_L	((uint8_t)0x0B)		// 8  bit RAW Value L Register; OPs ->R
	#define	SENSOR_AS72651_RAW_TIC_H	((uint8_t)0x0C)		// 8  bit RAW Value H Register; OPs ->R
	#define	SENSOR_AS72651_RAW_TIC_L	((uint8_t)0x0D)		// 8  bit RAW Value L Register; OPs ->R
	#define	SENSOR_AS72651_RAW_UJD_H	((uint8_t)0x0E)		// 8  bit RAW Value H Register; OPs ->R
	#define	SENSOR_AS72651_RAW_UJD_L	((uint8_t)0x0F)		// 8  bit RAW Value L Register; OPs ->R
	#define	SENSOR_AS72651_RAW_VKE_H	((uint8_t)0x10)		// 8  bit RAW Value H Register; OPs ->R
	#define	SENSOR_AS72651_RAW_VKE_L	((uint8_t)0x11)		// 8  bit RAW Value L Register; OPs ->R
	#define	SENSOR_AS72651_RAW_WLF_H	((uint8_t)0x12)		// 8  bit RAW Value H Register; OPs ->R
	#define	SENSOR_AS72651_RAW_WLF_L	((uint8_t)0x13)		// 8  bit RAW Value L Register; OPs ->R

	// DEVSELECT register Address
	#define	SENSOR_AS72651_DEVSEL_ADDR	(uint8_t)0x4F)		// 8  bit Device Select Address; OPs ->R/W

	//Values to write to the devselect register
	#define	SENSOR_AS72651_DEVSEL_MASTER	((uint8_t)0x00)		// 8 bit , write this to dev select register to select master
	#define	SENSOR_AS72651_DEVSEL_FIRSTSLAVE	((uint8_t)0x01)		// 8 bit , write this to dev select register to select first sensor slave
	#define	SENSOR_AS72651_DEVSEL_SECONDSLAVE	((uint8_t)0x02)		// 8 bit , write this to dev select register to select second sensor slave




	/*-----------------------------------------------------------------------------
	 * I2C Transmit and Receive buffers
	 */

	#define TX_LENGTH 1u
	#define TX_LENGTH_2 2u
	#define TX_LENGTH_3 3u
	#define RX_LENGTH 2u
	#define RX_LENGTH_2 1u

    // Defining the TX and RX Buffers
    uint8_t tx_buffer[TX_LENGTH] = {SENSOR_DEVICE_ID};
    uint8_t tx_buffer_2[TX_LENGTH] = {SENSOR_AS72651_STATUS_REG};

    uint8_t write_length = TX_LENGTH;
    uint8_t write_length_2 = TX_LENGTH_2;

    uint16_t rx_buffer[RX_LENGTH];
    uint8_t read_length = RX_LENGTH;

    uint8_t rx_buffer_2[RX_LENGTH_2];
    uint8_t read_length_2 = RX_LENGTH_2;

	/*-----------------------------------------------------------------------------
	 * I2C operation timeout value in mS. Define as I2C_NO_TIMEOUT to disable the
	 * timeout functionality.
	 */
	#define DEMO_I2C_TIMEOUT 3000u


	/*------------------------------------------------------------------------------
	 * MSS UART instance for UART1
	 */
	mss_uart_instance_t * const gp_my_uart = &g_mss_uart1;

	//Main Function of the example project started here
	    i2c_status_t instance;
	    uint8_t rx_size=0;
	    uint8_t rx_buff[1];
	    //uint8_t loop_count;

	    struct Beacon_packet_IS0{	// The beacon packet struct. It contains the CCSDS header and the data along with the fletcher code at the end.

	    	//To Add CCSDS Header
	        //struct CCSDS_Header beac_head;	// The CCSDS header

	        //To Add CDH HK Data
	        //uint8_t CDH_Subsystem_ON_Stat;
	        //uint16_t CDH_Temp;
	        //uint8_t CDH_Primary_Info;
	        //uint8_t CDH_Sub_System_Data_Valid_Flags;

	        //EPS HK Data
	        uint16_t EPS_Bat_Volt;
	        uint16_t EPS_Bat_Curr;
	        uint16_t EPS_Bus_Volt;
	        uint16_t EPS_Bus_Curr;
	        uint16_t EPS_Bat_SOC;
	        uint16_t EPS_Bat_Temp1;
	        uint16_t EPS_Bat_Temp2;
	        uint16_t EPS_SP1_Volt;
	        uint16_t EPS_SP2_Volt;
	        uint16_t EPS_SP3_Volt;
	        uint16_t EPS_SP1_Curr;
	        uint16_t EPS_SP2_Curr;
	        uint16_t EPS_SP3_Curr;
	        uint16_t EPS_Interface_Temp;
	        uint16_t EPS_EPS_Temp;
	        uint16_t EPS_CIP_Volt;
	        uint16_t EPS_CIP_Curr;
	        uint16_t EPS_ADCS_Volt;
	        uint16_t EPS_ADCS_Curr;
	        uint16_t EPS_SBAND_Volt;
	        uint16_t EPS_SBAND_Curr;
	        uint16_t EPS_UHF_Volt;
	        uint16_t EPS_UHF_Curr;
	        uint16_t EPS_CDH_Volt;
	        uint16_t EPS_CDH_Curr;
	        uint16_t EPS_GPS_33_Volt;
	        uint16_t EPS_GPS_33_Curr;
	        uint16_t EPS_GPS_12_Volt;
	        uint16_t EPS_GPS_12_Curr;
	        uint16_t EPS_Bat_Heater_Curr;
	        uint16_t EPS_DAXSS_Volt;
	        uint16_t EPS_DAXSS_Curr;

	        //Sensor Board AS7265X Data
	        uint8_t Sensor_Board_AS7265x_DataByte_1;
	        uint8_t Sensor_Board_AS7265x_DataByte_2;
	        uint8_t Sensor_Board_AS7265x_DataByte_3;
	        uint8_t Sensor_Board_AS7265x_DataByte_4;
	        uint8_t Sensor_Board_AS7265x_DataByte_5;
	        uint8_t Sensor_Board_AS7265x_DataByte_6;
	        uint8_t Sensor_Board_AS7265x_DataByte_7;
	        uint8_t Sensor_Board_AS7265x_DataByte_8;
	        uint8_t Sensor_Board_AS7265x_DataByte_9;
	        uint8_t Sensor_Board_AS7265x_DataByte_10;
	        uint8_t Sensor_Board_AS7265x_DataByte_11;
	        uint8_t Sensor_Board_AS7265x_DataByte_12;
	        uint8_t Sensor_Board_AS7265x_DataByte_13;
	        uint8_t Sensor_Board_AS7265x_DataByte_14;
	        uint8_t Sensor_Board_AS7265x_DataByte_15;
	        uint8_t Sensor_Board_AS7265x_DataByte_16;
	        uint8_t Sensor_Board_AS7265x_DataByte_17;
	        uint8_t Sensor_Board_AS7265x_DataByte_18;
	        uint8_t Sensor_Board_AS7265x_DataByte_19;
	        uint8_t Sensor_Board_AS7265x_DataByte_20;
	        uint8_t Sensor_Board_AS7265x_DataByte_21;
	        uint8_t Sensor_Board_AS7265x_DataByte_22;
	        uint8_t Sensor_Board_AS7265x_DataByte_23;
	        uint8_t Sensor_Board_AS7265x_DataByte_24;
	        uint8_t Sensor_Board_AS7265x_DataByte_25;
	        uint8_t Sensor_Board_AS7265x_DataByte_26;
	        uint8_t Sensor_Board_AS7265x_DataByte_27;
	        uint8_t Sensor_Board_AS7265x_DataByte_28;
	        uint8_t Sensor_Board_AS7265x_DataByte_29;
	        uint8_t Sensor_Board_AS7265x_DataByte_30;
	        uint8_t Sensor_Board_AS7265x_DataByte_31;
	        uint8_t Sensor_Board_AS7265x_DataByte_32;
	        uint8_t Sensor_Board_AS7265x_DataByte_33;
	        uint8_t Sensor_Board_AS7265x_DataByte_34;
	        uint8_t Sensor_Board_AS7265x_DataByte_35;
	        uint8_t Sensor_Board_AS7265x_DataByte_36;

	        //Sensor Board VMEL Data
	        uint8_t Sensor_Board_VMEL6075_UVA_DATA_L;
	        uint8_t Sensor_Board_VMEL6075_UVA_DATA_H;
	        uint8_t Sensor_Board_VMEL6075_UVB_DATA_L;
	        uint8_t Sensor_Board_VMEL6075_UVB_DATA_H;
	        uint8_t Sensor_Board_VMEL6075_UVCOMP1_DATA_L;
	        uint8_t Sensor_Board_VMEL6075_UVCOMP1_DATA_H;
	        uint8_t Sensor_Board_VMEL6075_UVCOMP2_DATA_L;
	        uint8_t Sensor_Board_VMEL6075_UVCOMP2_DATA_H;

	        //To Add the Fletcher Code
	        //uint16_t Fletcher_code;

	    } Beacon_pack_IS0;







void test3_IS0_Read_Sensor_Board_Data() {

	// This test is created to read channel 2 Voltage (DAXSS Voltage) of VC sensor 1 on the EPS Critical Channel 0
	// The enable of the switch is toggled and the voltage is read
	// The Voltage is then sent to the MSS UART to view on serial monitor
	//Global_Init_GPIOs();




	    /* Logging UART Initialization */
		MSS_UART_init(&g_mss_uart0,MSS_UART_115200_BAUD,MSS_UART_DATA_8_BITS | MSS_UART_NO_PARITY | MSS_UART_ONE_STOP_BIT);

	    /*-------------------------------------------------------------------------
	     * Initialize the Core I2C Drivers
	    */
	    I2C_init(&g_core_i2c0, COREI2C_0, MASTER_SER_ADDR, I2C_PCLK_DIV_960);
	    I2C_init(&g_core_i2c1, COREI2C_1, MASTER_SER_ADDR, I2C_PCLK_DIV_960);
	    I2C_init(&g_core_i2c2, COREI2C_2, MASTER_SER_ADDR, I2C_PCLK_DIV_960);
	    I2C_init(&g_core_i2c3, COREI2C_3, MASTER_SER_ADDR, I2C_PCLK_DIV_960);

	    /*-------------------------------------------------------------------------
	     * Initialize the system tick for 10mS operation or 1 tick every 100th of
	     * a second and also make sure it is lower priority than the I2C IRQs.
	    */
	    //NVIC_SetPriority(SysTick_IRQn, 0xFFu); /* Lowest possible priority */
	    //SysTick_Config(MSS_SYS_M3_CLK_FREQ / 100);

	    MSS_GPIO_init();
	    MSS_GPIO_config( MSS_GPIO_22, MSS_GPIO_OUTPUT_MODE);
	    MSS_GPIO_config( MSS_GPIO_25, MSS_GPIO_OUTPUT_MODE);
	    MSS_GPIO_config( MSS_GPIO_26, MSS_GPIO_OUTPUT_MODE);
	    MSS_GPIO_config( MSS_GPIO_30, MSS_GPIO_OUTPUT_MODE);



	    	//Sensor Board Testing Code
			//Enable Sensor Board - H1 18
	    	//MSS_GPIO_set_output( MSS_GPIO_22, 0);
			MSS_GPIO_set_output( MSS_GPIO_22, 1);

			//Reset Sensor Sensor Board - H2 50 - ALWAYS PULL HIGH
			MSS_GPIO_set_output( MSS_GPIO_25, 1);

			//Flash Write Protect of Sensor Board - H1 49 - ALWAYS PULL HIGH for reprogramming - CHECK THIS
			//MSS_GPIO_set_output( MSS_GPIO_22, 0);
			MSS_GPIO_set_output( MSS_GPIO_26, 0);

			//MSS_GPIO_30 For Chip select of the SPI
			MSS_GPIO_set_output( MSS_GPIO_30, 1);

			while(1){
			//VEML6075 Interfacing Code
			// By default VEML6075 seems to go into shut down mode , so needs to be turned ON by writing 0x0000 in CONF register
			// Working code for VEML Data read, for some reason write only is not working, so used write read
			// Also verify that the data should be 0x00 0x00

			uint8_t config_buffer[TX_LENGTH_3] = {SENSOR_VEML_UV_CONF, 0x00, 0x00};
			instance = do_write_read_transaction(&g_core_i2c3, SENSOR_VML, config_buffer, TX_LENGTH_3, rx_buffer, read_length); // This works!
			// Send the Data over the MSS UART for Logging
			MSS_UART_polled_tx( &g_mss_uart0, rx_buffer, sizeof(rx_buffer) );
			instance = do_write_read_transaction(&g_core_i2c3, SENSOR_VML, tx_buffer, TX_LENGTH, rx_buffer, read_length); // This works!
			// Send the Data over the MSS UART for Logging
			MSS_UART_polled_tx( &g_mss_uart0, rx_buffer, sizeof(rx_buffer) );

			//AS72651 Interfacing Code
			//Read Data from the AS72651
			uint8_t temp_buffer[TX_LENGTH] = {read_AS7265_reg(SENSOR_AS72651_SWVERSION_L)};

			// Send the Data over the MSS UART for Logging
			MSS_UART_polled_tx( &g_mss_uart0, temp_buffer, sizeof(temp_buffer) );


	    }

}


// ******************************** Sensor Board Read and Write Data Functions ****************************************************

//	This function is used to read a virtual register from the ASM7265 following the algorithm:
//	Poll I²C slave STATUS register;
//	If TX_VALID bit is 0, the virtual register address for the read may be written;
//	Send a virtual register address;
//	Poll I²C slave STATUS register;
//	If RX_VALID bit is 1, the read data is ready;
//	Read the data.

uint8_t read_AS7265_reg(uint8_t virtual_reg_address){

	 uint8_t status_reg_buffer[TX_LENGTH] = {SENSOR_AS72651_STATUS_REG};
	 uint8_t write_reg_buffer[TX_LENGTH] = {SENSOR_AS72651_WRITE_REG};
	 uint8_t read_reg_buffer[TX_LENGTH] = {SENSOR_AS72651_READ_REG};

	 while(1){
		 // Read slave I²C status to see if the read buffer is ready.
		 instance = do_write_transaction(&g_core_i2c3, SENSOR_MASTER, status_reg_buffer, write_length);

		 instance = do_read_transaction(&g_core_i2c3, SENSOR_MASTER, rx_buffer_2, read_length_2);
		 MSS_UART_polled_tx( &g_mss_uart0, rx_buffer_2, sizeof(rx_buffer_2) );
		 if((rx_buffer_2[0] & I2C_AS72651_SLAVE_TX_VALID) == 0){
			 // No inbound TX pending at slave. Okay to write now.
			 break;
		 }
	 }

	 // Send the virtual register address to the write buffer
	 uint8_t virtual_reg_buffer[TX_LENGTH_2] = {SENSOR_AS72651_WRITE_REG, virtual_reg_address};
	 instance = do_write_transaction(&g_core_i2c3, SENSOR_MASTER, virtual_reg_buffer, write_length_2);

	 while(1){
		 // Read the slave I²C status to see if our read data is available.
		 //instance = do_write_read_transaction(&g_core_i2c3, SENSOR_MASTER, status_reg_buffer, write_length, rx_buffer_2, read_length_2);

		 // Read slave I²C status to see if the read buffer is ready.
		 instance = do_write_transaction(&g_core_i2c3, SENSOR_MASTER, status_reg_buffer, write_length);


		 instance = do_read_transaction(&g_core_i2c3, SENSOR_MASTER, rx_buffer_2, read_length_2);

		 if((rx_buffer_2[0] & I2C_AS72651_SLAVE_RX_VALID)!=0){
		 		// Read data is ready.
		 		break;
		 }
	 }
	 // Read the data to complete the operation.
	 instance = do_write_read_transaction(&g_core_i2c3, SENSOR_MASTER, read_reg_buffer, write_length, rx_buffer_2, read_length_2);
	 MSS_UART_polled_tx( &g_mss_uart0, rx_buffer_2, sizeof(rx_buffer_2) );
	 return rx_buffer_2[0];
}



// ******************************** I2C Driver Functions ***************************************************************
/*------------------------------------------------------------------------------
	 * Perform read transaction with parameters gathered from the command line
	 * interface. This function is called as a result of the user's input in the
	 * command line interface.
	 */
	i2c_status_t do_read_transaction
	(
		i2c_instance_t * this_core_i2c,
	    uint8_t serial_addr,
	    uint8_t * rx_buffer,
	    uint8_t read_length
	)
	{
	    i2c_status_t status;

	    I2C_read(this_core_i2c, serial_addr, rx_buffer, read_length, I2C_RELEASE_BUS);

	    status = I2C_wait_complete(this_core_i2c, DEMO_I2C_TIMEOUT);

	    return status;
	}

	/*------------------------------------------------------------------------------
	 * Perform write transaction with parameters gathered from the command line
	 * interface. This function is called as a result of the user's input in the
	 * command line interface.
	 */
	i2c_status_t do_write_transaction
	(
		i2c_instance_t * this_core_i2c,
	    uint8_t serial_addr,
	    uint8_t * tx_buffer,
	    uint8_t write_length
	)
	{
	    i2c_status_t status;

	    I2C_write(this_core_i2c, serial_addr, tx_buffer, write_length, I2C_RELEASE_BUS);

	    status = I2C_wait_complete(this_core_i2c, DEMO_I2C_TIMEOUT);

	    return status;
	}

	/*------------------------------------------------------------------------------
	 * Perform write-read transaction with parameters gathered from the command
	 * line interface. This function is called as a result of the user's input in
	 * the command line interface.
	 */
	i2c_status_t do_write_read_transaction
	(
		i2c_instance_t * this_core_i2c,
	    uint8_t serial_addr,
	    uint8_t * tx_buffer,
	    uint8_t write_length,
	    uint8_t * rx_buffer,
	    uint8_t read_length
	)
	{
	    i2c_status_t status;

	    I2C_write_read(this_core_i2c,
	                       serial_addr,
	                       tx_buffer,
	                       write_length,
	                       rx_buffer,
	                       read_length,
	                       I2C_RELEASE_BUS);

	    status = I2C_wait_complete(this_core_i2c, DEMO_I2C_TIMEOUT);

	    return status;
	}

	/*------------------------------------------------------------------------------
	 * Service the I2C timeout functionality.
	 */
	void SysTick_Handler(void)
	{
	    I2C_system_tick(&g_core_i2c0, 10);
	    I2C_system_tick(&g_core_i2c1, 10);
	    I2C_system_tick(&g_core_i2c2, 10);
	    I2C_system_tick(&g_core_i2c3, 10);
	}


	void FabricIrq0_IRQHandler(void)
	{
	    I2C_isr(&g_core_i2c0);
	}

	void FabricIrq1_IRQHandler(void)
	{
	    I2C_isr(&g_core_i2c1);
	}

	void FabricIrq2_IRQHandler(void)
	{
	    I2C_isr(&g_core_i2c2);
	}

	void FabricIrq3_IRQHandler(void)
	{
	    I2C_isr(&g_core_i2c3);
	}



	// ******************************** I2C Driver Functions END ***************************************************************

	// ******************************** SensorBoard AS72651 Functions **********************************************************




	void test1_ISO_test_beacon_debug_UART() {
		//while(1){
		//MSS_UART_polled_tx( &g_mss_uart0, message, sizeof(message) );
		//}

		MSS_UART_init(&g_mss_uart0,MSS_UART_9600_BAUD,MSS_UART_DATA_8_BITS | MSS_UART_NO_PARITY | MSS_UART_ONE_STOP_BIT);
		uint8_t message[12] = "Hello World";


		//Enable Sensor Board - H1 18
		MSS_GPIO_set_output( MSS_GPIO_22, 0);
		MSS_GPIO_set_output( MSS_GPIO_22, 1);

		//Reset Sensor Sensor Board - H2 50 - ALWAYS PULL HIGH
		MSS_GPIO_set_output( MSS_GPIO_25, 1);

		//Flash Write Protect of Sensor Board - H1 49 - ALWAYS PULL HIGH
		MSS_GPIO_set_output( MSS_GPIO_26, 1);

		//Hydra Test
		uint8_t write_CCSDS_Dummy_Header[] = {0x08, 0x10 , 0x80 , 0x01 , 0x00, 0x0C , 0x00 , 0x00 , 0x00 ,0xFF, 0x00};
		MSS_UART_polled_tx( &g_mss_uart0, write_CCSDS_Dummy_Header, sizeof(write_CCSDS_Dummy_Header) );
		//Data
		uint8_t tx_buffer[TX_LENGTH] = {EPS_VC_CH3_BUS_VOLTAGE};
		instance = do_write_read_transaction(&g_core_i2c1, EPS_VC5_SLAVE_C1, tx_buffer, write_length, rx_buffer, read_length);
		MSS_UART_polled_tx( &g_mss_uart0, rx_buffer, sizeof(rx_buffer) );
		uint8_t tx_buffer_1[TX_LENGTH] = {EPS_VC_CH3_SHUNT_VOLTAGE};
		instance = do_write_read_transaction(&g_core_i2c1, EPS_VC5_SLAVE_C1, tx_buffer_1, write_length, rx_buffer, read_length);
		MSS_UART_polled_tx( &g_mss_uart0, rx_buffer, sizeof(rx_buffer) );

		uint8_t tx_buffer_2[TX_LENGTH] = {EPS_VC_CH3_BUS_VOLTAGE};
		instance = do_write_read_transaction(&g_core_i2c1, EPS_VC5_SLAVE_C1, tx_buffer_2, write_length, rx_buffer, read_length);
		MSS_UART_polled_tx( &g_mss_uart0, rx_buffer, sizeof(rx_buffer) );
		uint8_t tx_buffer_3[TX_LENGTH] = {EPS_VC_CH3_SHUNT_VOLTAGE};
		instance = do_write_read_transaction(&g_core_i2c1, EPS_VC5_SLAVE_C1, tx_buffer_3, write_length, rx_buffer, read_length);
		MSS_UART_polled_tx( &g_mss_uart0, rx_buffer, sizeof(rx_buffer) );

		//CIP
		uint8_t tx_buffer_4[TX_LENGTH] = {EPS_VC_CH3_BUS_VOLTAGE};
		instance = do_write_read_transaction(&g_core_i2c1, EPS_VC6_SLAVE_C1, tx_buffer_4, write_length, rx_buffer, read_length);
		MSS_UART_polled_tx( &g_mss_uart0, rx_buffer, sizeof(rx_buffer) );
		uint8_t tx_buffer_5[TX_LENGTH] = {EPS_VC_CH3_SHUNT_VOLTAGE};
		instance = do_write_read_transaction(&g_core_i2c1, EPS_VC6_SLAVE_C1, tx_buffer_5, write_length, rx_buffer, read_length);
		MSS_UART_polled_tx( &g_mss_uart0, rx_buffer, sizeof(rx_buffer) );

		//ADCS
		uint8_t tx_buffer_6[TX_LENGTH] = {EPS_VC_CH1_BUS_VOLTAGE};
		instance = do_write_read_transaction(&g_core_i2c1, EPS_VC6_SLAVE_C1, tx_buffer_6, write_length, rx_buffer, read_length);
		MSS_UART_polled_tx( &g_mss_uart0, rx_buffer, sizeof(rx_buffer) );
		uint8_t tx_buffer_7[TX_LENGTH] = {EPS_VC_CH1_SHUNT_VOLTAGE};
		instance = do_write_read_transaction(&g_core_i2c1, EPS_VC6_SLAVE_C1, tx_buffer_7, write_length, rx_buffer, read_length);
		MSS_UART_polled_tx( &g_mss_uart0, rx_buffer, sizeof(rx_buffer));

		//SBAND
		uint8_t tx_buffer_8[TX_LENGTH] = {EPS_VC_CH1_BUS_VOLTAGE};
		instance = do_write_read_transaction(&g_core_i2c0, EPS_VC2_SLAVE_C0, tx_buffer_8, write_length, rx_buffer, read_length);
		MSS_UART_polled_tx( &g_mss_uart0, rx_buffer, sizeof(rx_buffer) );
		uint8_t tx_buffer_9[TX_LENGTH] = {EPS_VC_CH1_SHUNT_VOLTAGE};
		instance = do_write_read_transaction(&g_core_i2c0, EPS_VC2_SLAVE_C0, tx_buffer_9, write_length, rx_buffer, read_length);
		MSS_UART_polled_tx( &g_mss_uart0, rx_buffer, sizeof(rx_buffer));

		//UHF
		uint8_t tx_buffer_10[TX_LENGTH] = {EPS_VC_CH2_BUS_VOLTAGE};
		instance = do_write_read_transaction(&g_core_i2c0, EPS_VC2_SLAVE_C0, tx_buffer_10, write_length, rx_buffer, read_length);
		MSS_UART_polled_tx( &g_mss_uart0, rx_buffer, sizeof(rx_buffer) );
		uint8_t tx_buffer_11[TX_LENGTH] = {EPS_VC_CH2_SHUNT_VOLTAGE};
		instance = do_write_read_transaction(&g_core_i2c0, EPS_VC2_SLAVE_C0, tx_buffer_11, write_length, rx_buffer, read_length);
		MSS_UART_polled_tx( &g_mss_uart0, rx_buffer, sizeof(rx_buffer));



		//CDH
		uint8_t tx_buffer_12[TX_LENGTH] = {EPS_VC_CH3_BUS_VOLTAGE};
		instance = do_write_read_transaction(&g_core_i2c0, EPS_VC1_SLAVE_C0, tx_buffer_12, write_length, rx_buffer, read_length);
		MSS_UART_polled_tx( &g_mss_uart0, rx_buffer, sizeof(rx_buffer) );
		uint8_t tx_buffer_13[TX_LENGTH] = {EPS_VC_CH3_SHUNT_VOLTAGE};
		instance = do_write_read_transaction(&g_core_i2c0, EPS_VC1_SLAVE_C0, tx_buffer_13, write_length, rx_buffer, read_length);
		MSS_UART_polled_tx( &g_mss_uart0, rx_buffer, sizeof(rx_buffer));


		uint8_t write_CCSDS_Dummy_Fletcher[] = {0x0F, 0x0F};
		MSS_UART_polled_tx( &g_mss_uart0, write_CCSDS_Dummy_Fletcher, sizeof(write_CCSDS_Dummy_Fletcher) );

	    //ADC Testing Code - We operate the ADC in mode 2

	    /* Perform write operation */
	    //instance = do_write_transaction(&g_core_i2c1, EPS_ADC_SLAVE_C1, tx_buffer, write_length);

	    /* Perform write-Read operation */
	    //instance = do_write_read_transaction(&g_core_i2c1, EPS_ADC_SLAVE_C1, tx_buffer, write_length, rx_buffer, read_length);

	    // Send the Data over the MSS UART for Logging
	    //MSS_UART_polled_tx( &g_mss_uart0, rx_buffer, sizeof(rx_buffer) );

	    //Disable Sband Switch
	    //MSS_GPIO_set_output( MSS_GPIO_2, 1);

	    /* Perform write-Read operation */
	    //instance = do_write_read_transaction(&g_core_i2c1, EPS_ADC_SLAVE_C1, tx_buffer_2, write_length, rx_buffer, read_length);

	    // Send the Data over the MSS UART for Logging
	    //MSS_UART_polled_tx( &g_mss_uart0, rx_buffer, sizeof(rx_buffer) );



	}

	void test4_ISO_PeakPower() {

		//Reset Sensor Sensor Board - H2 50 - ALWAYS PULL HIGH
		MSS_GPIO_set_output( MSS_GPIO_25, 1);

		//Flash Write Protect of Sensor Board - H1 49 - ALWAYS PULL HIGH
		MSS_GPIO_set_output( MSS_GPIO_26, 1);

		//DSW - 0 - H1 13 - DAXSS SWITCH - Enables 8.4V at H1 pins 3 and 5
		MSS_GPIO_set_output( MSS_GPIO_1, 1);

		//DSW - 1 - H1 14 - CIP SWITCH - Enables 12V at H2 pin 23
		MSS_GPIO_set_output( MSS_GPIO_2, 1);

		//DSW - 2 - H1 15 - ADCS_GPS SWITCH - Enables 12V at H1 pin 30
		//Also Enables 12 V at H2 Pin 15, 17, 19 and enables 3.3V at H2 pin 16
		MSS_GPIO_set_output( MSS_GPIO_3, 1);

		//DSW - 3 - H1 16 - SBAND SWITCH - Enables 6V at H2 Pin 11
		MSS_GPIO_set_output( MSS_GPIO_4, 1);


		//DSW - 4 - H1 17 - BATTERY HEATER SWITCH -
		MSS_GPIO_set_output( MSS_GPIO_5, 1);

		//Enable Sensor Board - H1 18
		MSS_GPIO_set_output( MSS_GPIO_22, 1);

		MSS_GPIO_set_output( MSS_GPIO_22, 0);
		MSS_GPIO_set_output( MSS_GPIO_1, 0);
		MSS_GPIO_set_output( MSS_GPIO_5, 0);
		MSS_GPIO_set_output( MSS_GPIO_4, 0);
		MSS_GPIO_set_output( MSS_GPIO_3, 0);
		MSS_GPIO_set_output( MSS_GPIO_2, 0);


	}

	void test2_ISO_GPIO_Subsystem_Enable_GPIOs() {
		//while(1){

		//DSW - 0 - H1 13 - DAXSS SWITCH - Enables 8.4V at H1 pins 3 and 5
		MSS_GPIO_set_output( MSS_GPIO_1, 1);
		MSS_GPIO_set_output( MSS_GPIO_1, 0);

		//DSW - 1 - H1 14 - CIP SWITCH - Enables 12V at H2 pin 23
		MSS_GPIO_set_output( MSS_GPIO_2, 1);
		MSS_GPIO_set_output( MSS_GPIO_2, 0);

		//DSW - 2 - H1 15 - ADCS_GPS SWITCH - Enables 12V at H1 pin 30
		//Also Enables 12 V at H2 Pin 15, 17, 19 and enables 3.3V at H2 pin 16
		MSS_GPIO_set_output( MSS_GPIO_3, 1);
		MSS_GPIO_set_output( MSS_GPIO_3, 0);

		//DSW - 3 - H1 16 - SBAND SWITCH - Enables 6V at H2 Pin 11
		MSS_GPIO_set_output( MSS_GPIO_4, 1);
		MSS_GPIO_set_output( MSS_GPIO_4, 0);

		//DSW - 4 - H1 17 - BATTERY HEATER SWITCH -
		MSS_GPIO_set_output( MSS_GPIO_5, 1);
		MSS_GPIO_set_output( MSS_GPIO_5, 0);

		//To Test Tomorrow

		//CONVEST Signal for ADC - H1 6
		MSS_GPIO_set_output( MSS_GPIO_6, 1);
		MSS_GPIO_set_output( MSS_GPIO_6, 0);

		//Enable Sensor Board - H1 18
		MSS_GPIO_set_output( MSS_GPIO_22, 1);
		MSS_GPIO_set_output( MSS_GPIO_22, 0);

		//Reset Sensor Sensor Board - H2 50 - ALWAYS PULL HIGH
		MSS_GPIO_set_output( MSS_GPIO_25, 1);
		MSS_GPIO_set_output( MSS_GPIO_25, 0);
		MSS_GPIO_set_output( MSS_GPIO_25, 1);

		//Flash Write Protect of Sensor Board - H1 49 - ALWAYS PULL HIGH
		MSS_GPIO_set_output( MSS_GPIO_26, 1);
		MSS_GPIO_set_output( MSS_GPIO_26, 0);
		MSS_GPIO_set_output( MSS_GPIO_26, 1);
		//}

		}



//*************************** OLD IS1 Tests ******************************//
void test_main_seq(){
	main_seq();
}


void test_SD_Card(){
	Global_Init_GPIOs();
	PWR_Switch(GPIO_DSW0_DAXSS_Mask, 0);
	uint8_t sig = 0;

	sig = 1;
	PWR_Switch(GPIO_DSW0_DAXSS_Mask, sig);

	Globals.Current_SD = SD_Select_Init();

	sig = 0;
	PWR_Switch(GPIO_DSW0_DAXSS_Mask, sig);
	uint16_t data_L = 512;uint64_t i;
	uint8_t w_data[data_L], r_data[data_L];
	for (i =0; i<data_L; i++){
		w_data[i]=i%9;
		r_data[i] = 0;
	}
	sig = 1;
	PWR_Switch(GPIO_DSW0_DAXSS_Mask, sig);
	i = SD_Write_Data(w_data, data_L, 4, Globals.Current_SD);
	sig = 0;
	PWR_Switch(GPIO_DSW0_DAXSS_Mask, sig);
	while(1){
		sig = 1;
		PWR_Switch(GPIO_DSW0_DAXSS_Mask, sig);
		i = SD_Read_Data(r_data, data_L, 4, Globals.Current_SD);
		sig = 0;
		PWR_Switch(GPIO_DSW0_DAXSS_Mask, sig);
		i = FLASH_Verify_write(w_data, r_data, data_L);
		if( i != data_L){
			sig = !sig;
		}
		memset(r_data, 0, data_L);
	}
}

void test_SD_Write_Packets() {
	Init();
	uint8_t beac_write_addr = Globals.Beacon_Write_Start;
	uint8_t read_data[512], j;
	uint16_t i=0,err=0;
	while(1) {
		Beacon_Timer_Handler();
		if (beac_write_addr < Globals.Beacon_Write_Start) {
			j = SD_Read_Sector(read_data, beac_write_addr, Globals.Current_SD, 512);
			if (!j) {
				j = 1;
				j = 0;
			}
			beac_write_addr = Globals.Beacon_Write_Start;
			for (i=0,err=0; i<BEACON_PACKET_SIZE; i++) {
				if (read_data[i+2] != ((uint8_t *)&Beacon_pack)[i]){
					err++;
				}
			}
			if (err > 5) {
				return;
			}
			Beacon_pack.ADCS_Body_Frame_Rate3++;
			Beacon_pack.EPS_Bat_Heater_Curr++;
		}
	}
}

void test_save_parameter_character(){
	Global_Init_GPIOs();
	Flash_Init();
	uint8_t sig2 = 0;
	while(1){
		Load_Factory_Value();
//		if(Globals.Param_Module_sync.CMD_Seq_Count == FLASH_STATE_IDLE){
//			Globals.Param_Module_sync.CMD_Seq_Count = FLASH_STATE_ERASE_CMD;
//		}
		statusG = Save_Parameter_Table();
//		statusG = Load_Parameter_Table();
		sig2 = !sig2;
		PWR_Switch(GPIO_DSW1_CIP_Mask, sig2);
		if(statusG == 0){
			continue;
		}
		if(Globals.Subsystem_Restart_Limit != 0x03){
			continue;
		}
	}
}


void test_RTC(){
	uint8_t v[] = {0x01, 0x02, 0x03, 0x04, 0x05};
	uint8_t r[] = {0x00, 0x00, 0x00, 0x00, 0x00};
	uint64_t val = 0;
	RTC_Reset();
	val = RTC_Get_Value64();	// Gets value from counter 1
	RTC_Get_Value_Pointer1(r);	// Gets value from counter 2

	RTC_Enable();
	RTC_Set_Value(v,5);
	while(1){
		// Test to check if reset and enable function works properly
		/*RTC_Get_Value_Pointer1(r);	// Fetch absolute rtc value
		RTC_Set_Value(uint8_t * v, uint8_t len)
		d = RTC_Get_Value64();	// Fetch process rtc value
		d = RTC_Reset();
		d = RTC_Enable();
		RTC_Get_Value_Pointer1(r);	// Fetch absolute rtc value
		d = RTC_Get_Value64();	// Fetch process rtc value*/

		// Test to check if enable function works properly
		/*d = RTC_Enable();
		d = RTC_Get_Value64();
		d = RTC_Get_Value64();
		d = RTC_Get_Value64();
		d = RTC_Get_Value64();
		RTC_Get_Value_Pointer1(r);
		RTC_Get_Value_Pointer1(r);
		RTC_Get_Value_Pointer1(r);*/

		// Test to check if Set Value fnction works properly
		/*RTC_Disable();
		d = RTC_Set_Value(v, sizeof(v));
		d = RTC_Get_Value64();
		d = RTC_Get_Value64();
		d = RTC_Get_Value64();*/
		/*d = RTC_Enable();
		for (int i=0;i<10;i++){
		RTC_Get_Value_Pointer1(r);
		//r[0] = 0x00; r[1] =  0x00; r[2] = 0x00; r[3] = 0x00; r[4] = 0x00;
		}*/

		/*RTC_Get_Value_Pointer1(r);
		RTC_Get_Value_Pointer1(r);*/

		// Keep reading values and see if increments
		/*RTC_Get_Value_Pointer1(r);
		d = RTC_Get_Value64();
		d = RTC_Get_Value64();
		d = RTC_Get_Value64();
		d = RTC_Get_Value64();
		RTC_Get_Value_Pointer1(r);*/

		// Generic RTC test routine
		val = RTC_Get_Value64();	// Gets value from counter 1
		RTC_Get_Value_Pointer1(r);	// Gets value from counter 2

		//RTC_Set_Value(v,5);			// Resets counter 2 value to v


	}
}




void spi_flash_test2(){
    volatile uint32_t errors = 0;
    uint32_t address = 0;
    uint16_t loop_count;

    for(loop_count = 0; loop_count < (BUFFER_A_SIZE/2); loop_count++)
    {
        g_flash_wr_buf[loop_count] = 0+loop_count;
        g_flash_rd_buf[loop_count] = 0x00;
    }
    for(loop_count = (BUFFER_A_SIZE/2); loop_count < BUFFER_A_SIZE; loop_count++)
    {
        g_flash_wr_buf[loop_count] = 0x33;
        g_flash_rd_buf[loop_count] = 0x00;
    }
    Flash_Init();

    while(1){
        uint8_t res[10];
        uint8_t cmd[10];

        MSS_SPI_set_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
        Flash_Write_EN_DIS(FLASH_WREN);
        MSS_SPI_clear_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );

        cmd[0] = FLASH_RDSR1;
        Flash_CMD(cmd, 1, res, 1);

        uint8_t res2 = Flash_Read_Status_Register_1();
        res2 = Flash_Read_Status_Register_1();

        MSS_SPI_set_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
        Flash_Write_EN_DIS(FLASH_WRDI);
        MSS_SPI_clear_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );

        res2 = Flash_Read_Status_Register_1();
        res2 = Flash_Read_Status_Register_1();



//      cmd[0] = FLASH_WRR;cmd[1] = 0;
//      Flash_CMD(cmd, 2, 0,0,0);

        Flash_CMD(cmd, 1, res, 1);
        cmd[0] = FLASH_RDSR2;
        Flash_CMD(cmd, 1, res, 1);
        cmd[0] = FLASH_RDCR1;
        Flash_CMD(cmd, 1, res, 1);

        cmd[0] = FLASH_READ_ID; cmd[1] = 0; cmd[2] = 0; cmd[3] = 0; cmd[4] = 0;
        Flash_CMD(cmd, 5, res, 2);


        address = 0x00020000;
        uint32_t stat = Flash_Erase(FLASH_SE, address);
        uint8_t p;
        cmd[0] = FLASH_RDSR1;
//      while(1){
            MSS_GPIO_set_output(MSS_GPIO_1, 1);

            Flash_CMD(cmd, 1, res, 1);
//          p = Flash_CMD_Read();
//          MSS_SPI_set_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
//          p=FLASH_get_status();
//          MSS_SPI_clear_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
//          Flash_Read_Data(0x00020000, g_flash_rd_buf, sizeof(g_flash_wr_buf));
            MSS_GPIO_set_output(MSS_GPIO_1, 0);
//      }

        address = 0x00030000;
        stat = Flash_Erase(FLASH_SE, address);
        Flash_Read_Data(0x00030000, g_flash_rd_buf, sizeof(g_flash_wr_buf));
        address = 0x00040000;
        stat = Flash_Erase(FLASH_SE, address);
        Flash_Read_Data(0x00040000, g_flash_rd_buf, sizeof(g_flash_wr_buf));

        address = 0x00020000;
        Flash_Program(address, g_flash_wr_buf, sizeof(g_flash_wr_buf));
        Flash_Read_Data(address, g_flash_rd_buf, sizeof(g_flash_wr_buf));
        errors = FLASH_Verify_write(g_flash_rd_buf, g_flash_wr_buf, sizeof(g_flash_wr_buf));

        address = 0x00030000;
        Flash_Program(address, g_flash_wr_buf, sizeof(g_flash_wr_buf));
        Flash_Read_Data(address, g_flash_rd_buf, sizeof(g_flash_wr_buf));
        errors = FLASH_Verify_write(g_flash_rd_buf, g_flash_wr_buf, sizeof(g_flash_wr_buf));

        address = 0x00040000;
        Flash_Program(address, g_flash_wr_buf, sizeof(g_flash_wr_buf));
        Flash_Read_Data(address, g_flash_rd_buf, sizeof(g_flash_wr_buf));
        errors = FLASH_Verify_write(g_flash_rd_buf, g_flash_wr_buf, sizeof(g_flash_wr_buf));

        address= 0x00030000;
        Flash_Erase(FLASH_SE, address);
        Flash_Read_Data(address, g_flash_rd_buf, sizeof(g_flash_wr_buf));

        address= 0x00020000;
        Flash_Read_Data(address, g_flash_rd_buf, sizeof(g_flash_wr_buf));
        errors = FLASH_Verify_write(g_flash_rd_buf, g_flash_wr_buf, sizeof(g_flash_wr_buf));

        address= 0x00030000;
        Flash_Read_Data(address, g_flash_rd_buf, sizeof(g_flash_wr_buf));
        errors = FLASH_Verify_write(g_flash_rd_buf, g_flash_wr_buf, sizeof(g_flash_wr_buf));

        address= 0x00040000;
        Flash_Read_Data(address, g_flash_rd_buf, sizeof(g_flash_wr_buf));
        errors = FLASH_Verify_write(g_flash_rd_buf, g_flash_wr_buf, sizeof(g_flash_wr_buf));


    }

}



int test_SD_All_Sectors(mss_spi_slave_t slot, uint16_t sd_size) {
	Global_Init_GPIOs();
	SD_enable(slot);
	uint32_t sector,i;
	uint8_t data[SD_TEST_DATA_SIZE];
	uint8_t rx_data[SD_TEST_DATA_SIZE+2];
	int errs=0;

	// init data buffers
	for (i = 0; i < SD_TEST_DATA_SIZE; i++) {
		data[i] = i % 128;
		//data[i] = 0;
		rx_data[i] = 0;
	}

	SD_Init(slot);
	uint32_t max_size = sd_size == 16 ? SD_MAX_SECTOR_VALUE_16 : SD_MAX_SECTOR_VALUE_128;
	for (sector = 4; sector < max_size; sector++) {
		i = SD_Write_Data(data, SD_TEST_DATA_SIZE, sector, 0);
		if (i != sector+1)
			errs++;
		i = SD_Read_Data(rx_data, 512, sector, 0);
		if (i != sector + 1)
			errs++;
		i = FLASH_Verify_write(data, rx_data, SD_TEST_DATA_SIZE);
		if (i != SD_TEST_DATA_SIZE)
			errs++;

		if(sector%256 == 0){
			i=0;  //dummy command so that I can add a breakpoint
		}

		//change data buffers for accuracy of test
		for (i = 0; i < SD_TEST_DATA_SIZE; i++) {
				data[i] = i % 128 + sector;
				rx_data[i] = 0;
			}
	}

	SD_Card_Wipe(slot);
	return errs;

}

#define PWR_SWITCHING
int test_eps_subsystem_power_nonblocking(void) {
	Init();
	PWR_Init_Comm();
	int err = 0;
	enum subsystem_power {
		MANAGE,
		DAXSS,
		CIP,
		SBAND,
		ADCS
	};
	Derek_Timer16_t pwr_timer;
	Derek_Timer16_t dog_timer;
	dog_timer.time = 100;
	Utils_Start_Derek_Timer16(&dog_timer, dog_timer.time);
	pwr_timer.time = 10000;
	uint8_t state = MANAGE;
	uint8_t prev_state = MANAGE;

	while (1) {
		if (Utils_isTimeout_Derek_Timer16(&dog_timer)) {
			Watchdog_Pet();
			Utils_Start_Derek_Timer16(&dog_timer, dog_timer.time);
		}
#ifdef PWR_SWITCHING
		switch (state) {
			case MANAGE:
				if (!Utils_isStarted_Derek_Timer16(&pwr_timer)) {
					// start the wait timer.
					Utils_Start_Derek_Timer16(&pwr_timer, pwr_timer.time);
				}

				else if (Utils_isTimeout_Derek_Timer16(&pwr_timer)) {
					state = prev_state + 1;
					// start the power timer.
					Utils_Start_Derek_Timer16(&pwr_timer, pwr_timer.time);
				}
				break;
			case DAXSS:
				// timer started in MANAGE. We just check timeout
				if (Utils_isTimeout_Derek_Timer16(&pwr_timer)) {
					prev_state = DAXSS;
					state = MANAGE;
					PWR_Switch(GPIO_DSW0_DAXSS_Mask, 0);
					break;
				}
				// turn on DAXSS
				PWR_Switch(GPIO_DSW0_DAXSS_Mask, 1);
				break;
			case CIP:
				if (Utils_isTimeout_Derek_Timer16(&pwr_timer)) {
					prev_state = CIP;
					state = MANAGE;
					//turn off CIP
					PWR_Switch(GPIO_DSW1_CIP_Mask, 0);
					break;
				}
				// turn on CIP
				PWR_Switch(GPIO_DSW1_CIP_Mask, 1);
				break;
			case SBAND:
				if (Utils_isTimeout_Derek_Timer16(&pwr_timer)) {
					prev_state = SBAND;
					state = MANAGE;
					//turn off SBAND
					PWR_Switch(GPIO_DSW3_Sband_Mask, 0);
					break;
				}
				// turn on SBAND
				PWR_Switch(GPIO_DSW3_Sband_Mask, 1);
				break;
			case ADCS:
				if (Utils_isTimeout_Derek_Timer16(&pwr_timer)) {
					prev_state = ADCS;
					state = MANAGE;
					//turn off adcs
					PWR_Switch(GPIO_DSW1_CIP_Mask, 0);
					break;
				}
				// turn on ADCS
				PWR_Switch(GPIO_DSW1_CIP_Mask, 1);
				break;
			default:
				return err;
		}
#endif

	}

}


#endif
