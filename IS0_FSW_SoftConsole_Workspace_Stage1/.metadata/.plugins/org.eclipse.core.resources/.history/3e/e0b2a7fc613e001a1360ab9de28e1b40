
// All global variables and functions start with capital letter and separated by '_'.

#ifndef _MAIN_SEQ_C
    #define _MAIN_SEQ_C

#include <EPS/eps.h>
#include "Seq_ops/main_seq.h"
#include "CCSDS/ccsds.h"
#include "SD_CARD/sd.h"
#include "RTC/rtc.h"
#include "gpios.h"
#include "UART/UART_RX_V3.h"
#include "UART/UART_TX.h"
#include "Utils/utils.h"
#include "string.h"
#include "Test/test.h"
#include "../../CMSIS/mss_assert.h"
#include "SPI_Flash/spi_flash.h"



void do_nothing() {
	while(1);
}

uint32_t ret_val;
uint8_t sig = 0;
int main(){


//	test_ISO_GPIO_Subsystem_Enable_GPIOs();
//	test_ISO_PeakPower();
	test_ISO_test_beacon_debug_UART();
	test_IS0_Read_Sensor_Board_Data();




}


void main_seq(){

	//Do Nothing Here for Now
}

void Init(){

}

void RTC_Sync_Timer_Hanlder(){
  if(Utils_Handle_Timer32_Started(&Globals.RTC_Sync_Timer)){
    Globals.Indication_Flags |= UPDATE_RTC_GPS;
  }
}

void Last_Command_Timer_Handler(){
    if(Utils_Handle_Timer32(&Globals.Last_Command_Timer,  LAST_COMMAND_TIMER_STARTED_FLAG)){
        Make_Log_packet("No command received, restarting", sizeof("No command received, restarting"));
//        SC_Restart();
    }
}

void PSLV_Wait_Timer_Handler(){
    if((Globals.Deps_Wait_Tumb_Flag & PSLV_WAIT_FLAG) > 0){
        if(Utils_Handle_Timer32(&Globals.PSLV_Wait_Timer, PSLV_WAIT_TIMER_STARTED_FLAG)){
            Globals.Deps_Wait_Tumb_Flag &= (~PSLV_WAIT_FLAG);
            Globals.Indication_Flags |= SAVE_PARAMETER_MAP_FLAG;    /* Save parameter map flag is set */
        }
    }
}

void Deployment_Timer_Handler(){
    if(((Globals.Deps_Wait_Tumb_Flag & PSLV_WAIT_FLAG) == 0) && ((Globals.Deps_Wait_Tumb_Flag & (SP1_DEPLOYMENT_FLAG | SP2_DEPLOYMENT_FLAG | ANT_DEPLOYMENT_FLAG)) > 0)){

        if((Globals.Timers_Started_Flag & DEPLOYMENT_WAIT_TIMER_STARTED_FLAG) == 0){
            Globals.Timers_Started_Flag |= DEPLOYMENT_WAIT_TIMER_STARTED_FLAG;
            Globals.Deployment_Wait_Timer.Start = RTC_Get_Value32();
            PWR_Switch(GPIO_DEP_SP1_Mask | GPIO_DEP_SP2_Mask | GPIO_DEP_ANT_Mask, PWR_SWITCH_OFF);
            return;
        }

        if(Utils_Handle_Timer32_Started(&Globals.Deployment_Wait_Timer)){   /* 30 minutes */
            if((Globals.Timers_Started_Flag & DEPLOYMENT_DURATION_TIMER_STARTED_FLAG) > 0){
                if(Utils_Handle_Timer16_Started(&Globals.Deployment_Duration_Timer)){    /* 60 seconds */
                    Globals.Deployment_Wait_Timer.Start = RTC_Get_Value32();
                    PWR_Switch(GPIO_DEP_SP1_Mask |GPIO_DEP_SP2_Mask | GPIO_DEP_ANT_Mask, PWR_SWITCH_OFF);
                    Globals.Timers_Started_Flag &= ~DEPLOYMENT_DURATION_TIMER_STARTED_FLAG;
                }
                return;
            }
            Globals.Deployment_Duration_Timer.Start = RTC_Get_Value16();

            uint8_t state = (Globals.Deps_Wait_Tumb_Flag & SP1_DEPLOYMENT_FLAG) > 0 ? PWR_SWITCH_ON : PWR_SWITCH_OFF;
            PWR_Switch(GPIO_DEP_SP1_Mask, state);

            state = (Globals.Deps_Wait_Tumb_Flag & SP2_DEPLOYMENT_FLAG) > 0 ? PWR_SWITCH_ON : PWR_SWITCH_OFF;
            PWR_Switch(GPIO_DEP_SP1_Mask, state);

            state = (Globals.Deps_Wait_Tumb_Flag & ANT_DEPLOYMENT_FLAG) > 0 ? PWR_SWITCH_ON : PWR_SWITCH_OFF;
            PWR_Switch(GPIO_DEP_SP1_Mask, state);

            Globals.Timers_Started_Flag |= DEPLOYMENT_DURATION_TIMER_STARTED_FLAG;
        }
    }
}


void HK_Timer_Handler(){
    if(Utils_Handle_Timer32(&Globals.HK_Timer, HK_TIMER_STARTED_FLAG)){
//        Store_HK_Data();
    }
}

void Store_HK_Data(){
  uint32_t * write_addr = &Globals.HK_Write_Start;
  uint8_t to_write[sizeof(HK_pack)+SIZEOF_SYNC_WORD];
  memcpy(to_write, (const void * restrict) SBAND_SYNC_WORD, SIZEOF_SYNC_WORD);
  memcpy(&to_write[SIZEOF_SYNC_WORD], &HK_pack, sizeof(HK_pack));
  uint8_t i = 0, tries = 0;
  //try up to 4 times
  while((i < (*write_addr + 1)) && (tries < 4)) {
    i = SD_Write_Data(to_write, sizeof(HK_pack) + SIZEOF_SYNC_WORD, *write_addr, Globals.Current_SD);
    tries++;
  }
  if (tries != 4) {
    //update Write_Start if successful
    *write_addr = i;
  }
}

void Beacon_Timer_Handler(){
    if(Utils_Handle_Timer32(&Globals.Beac_Timer, BEAC_TIMER_STARTED_FLAG)){
        Beacon_pack.CDH_Primary_Info = (Globals.Sat_Curr_Mode  & 0x07);
        Beacon_pack.CDH_Primary_Info |= (((Globals.Indication_Flags & IS_ECLIPSE) >> 4) & 0x80); /* The solar panel threshold is to be updated*/
        Beacon_pack.CDH_Primary_Info |= !(MSS_GPIO_get_outputs() & GPIO_EN_BUS_TRAN_Mask) << 4;
        Beacon_pack.CDH_Subsystem_ON_Stat = PWR_Update_SW_Data();
        Beacon_pack.CDH_Last_CMD_APID = Globals.Last_CMD_Rec.apid;
        Beacon_pack.CDH_Last_CMD_Option1 = Globals.Last_CMD_Rec.option1;
        Beacon_pack.CDH_Last_CMD_Option2 = Globals.Last_CMD_Rec.option2;

        Beacon_pack.CDH_Indication_Flags = Globals.Indication_Flags;

        Beacon_pack.CDH_ADCS_Read_start = Globals.ADCS_Read_Start;
        Beacon_pack.CDH_Beacon_Read_start = Globals.Beacon_Read_Start;
        Beacon_pack.CDH_HK_Read_start = Globals.HK_Read_Start;
        Beacon_pack.CDH_Log_Read_start = Globals.Log_Read_Start;
        Beacon_pack.CDH_SciC_Read_start = Globals.SciC_Read_Start;
        Beacon_pack.CDH_SciD_Read_start = Globals.SciD_Read_Start;

        Beacon_pack.CDH_ADCS_Write_start = Globals.ADCS_Write_Start;
        Beacon_pack.CDH_Beacon_Write_start = Globals.Beacon_Write_Start;
        Beacon_pack.CDH_HK_Write_start = Globals.HK_Write_Start;
        Beacon_pack.CDH_Log_Write_start = Globals.Log_Write_Start;
        Beacon_pack.CDH_SciC_Write_start = Globals.SciC_Write_Start;
        Beacon_pack.CDH_SciD_Write_start = Globals.SciD_Write_Start;


        uint32_t Curr = RTC_Get_Value32();
        /* Taking care of timer overflow */
        if (Curr < Globals.Last_Command_Timer.Start){
            Curr += (0xffffffff - Globals.Last_Command_Timer.Start);
        }else{
            Curr -= Globals.Last_Command_Timer.Start;
        }
        Beacon_pack.CDH_Last_CMD_Timer = Curr;

        CCSDS_Pack( BEACON_PACKET_APID, 0xC0, Globals.Beacon_Packet_Seq_Counter, (struct CCSDS_Header *)&(Beacon_pack.beac_head), sizeof(Beacon_pack));
        CCSDS_Fletcher_16((uint8_t *)(&Beacon_pack), sizeof(Beacon_pack) - 2);
        Globals.Beacon_Packet_Seq_Counter++;

        Store_Beacon_Data();

    }
}

void Store_Beacon_Data(){
  if (Globals.Current_SD == 0xff) {
	  return;
  }
  uint32_t * write_addr = &Globals.Beacon_Write_Start;
  uint16_t sync = SBAND_SYNC_WORD;
  uint16_t * sync_ptr = &sync;
  uint8_t to_write[sizeof(Beacon_pack)+SIZEOF_SYNC_WORD];
  memcpy(to_write, (uint8_t *)sync_ptr, SIZEOF_SYNC_WORD);
  memcpy(&to_write[SIZEOF_SYNC_WORD], &Beacon_pack, sizeof(Beacon_pack));
  uint32_t i = 0;
  uint8_t tries = 0;
  //try up to 4 times
  while((i < (*write_addr + 1)) && (tries < 4)) {
    i = SD_Write_Data(to_write, sizeof(Beacon_pack) + SIZEOF_SYNC_WORD, *write_addr, Globals.Current_SD);
    tries++;
  }
  if (tries < 4) {
    //update Write_Start if successful
    *write_addr = (i <= Globals.Beacon_Sector_End) ? i : Globals.Beacon_Sector_Start;
    //TODO: figure out when/how often to update Write_Start flag in flash -- being changed every second
    // how about every time we transmit beacon packet, we update parameter table.
//    if (Globals.Beacon_Packet_Seq_Counter % Beacon_Write_Start_Update_Cnt == 0) {
//    Globals.Indication_Flags |= SAVE_PARAMETER_MAP_FLAG;
//    }
  }
  else {
	  Globals.Current_SD = 0xff;
	  return;
  }

}



void Watchdog_Timer_Handler(){
    if(Utils_Handle_Timer16(&Globals.Watchdog_Signal_Timer, WATCHDOG_SIGNAL_TIMER_FLAG)){
        Watchdog_Pet();
    }
}

void Watchdog_Pet() {
	uint32_t k = (MSS_GPIO_get_outputs() & GPIO_RESET_IC_Mask);
	//toggle k
	k = k == 0;
	MSS_GPIO_set_output(GPIO_RESET_IC, k);
}


void Decide_Mode(){

}

void SC_Restart(){
   uint8_t i = 0, j = 0;
   for(i = 0; i < 10; i++){
       j = 0;
       MSS_GPIO_set_output(GPIO_RESET_IC, 0);
       while(j < SC_REBOOT_SIGNAL_DELAY){
           j++;
       }
       MSS_GPIO_set_output(GPIO_RESET_IC, 1);
   }
}


void Utils_SPI_Custom_Setup(mss_spi_instance_t * this_spi, uint16_t frame_count){
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));

    /* This function is only intended to be used with an SPI master. */
    ASSERT((this_spi->hw_reg->CONTROL & CTRL_MASTER_MASK) == CTRL_MASTER_MASK);

    /* Flush the Tx and Rx FIFOs. */
    this_spi->hw_reg->COMMAND |= (TX_FIFO_RESET_MASK | RX_FIFO_RESET_MASK);

    /* Set frame size and the frame count .*/
    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
    this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~TXRXDFCOUNT_MASK) | ( (frame_count << TXRXDFCOUNT_SHIFT) & TXRXDFCOUNT_MASK);
    this_spi->hw_reg->TXRXDF_SIZE = MAX_FRAME_LENGTH;
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;

}


/* This function is suppose to be in Utils.c file but something is going wrong with it in when kept in the file
 * hence it is kept here.*/
uint16_t Utils_SPI_Transmit_Block(mss_spi_instance_t * this_spi, uint8_t * cmd_buffer, uint16_t cmd_byte_size){
    if(cmd_byte_size == 0)
        return 0;

    uint16_t transfer_idx = 0u;
    int16_t tx_idx;
    uint16_t c;
    uint32_t frame_count;
    uint32_t tx_fifo_empty;

    Utils_SPI_Custom_Setup(this_spi, cmd_byte_size);

    tx_idx = 0u;c = 0;
    /* Perform the remainder of the transfer by sending 4 bytes at a time.
     * This should ensure that no Rx overflow can happen in
     * case of an interrupt occurs during this function. */
    while(transfer_idx < cmd_byte_size)
    {

        tx_fifo_empty = this_spi->hw_reg->STATUS & TX_FIFO_EMPTY_MASK;
        if(TX_FIFO_EMPTY_MASK == tx_fifo_empty)
        {
            tx_idx = cmd_byte_size - transfer_idx;
            /* Send another 4 bytes. */
            if(tx_idx >= MAX_FRAME_LENGTH/8)
            {
                this_spi->hw_reg->TX_DATA = Utils_Buffer_to_32_ValueS_Big(&cmd_buffer[transfer_idx]);
                transfer_idx += 4;
            }
            else
            {
                this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
                this_spi->hw_reg->TXRXDF_SIZE = MSS_SPI_BLOCK_TRANSFER_FRAME_SIZE;
                this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;

                this_spi->hw_reg->TX_DATA = cmd_buffer[transfer_idx];
                ++transfer_idx;
            }
            c=0;
            continue;
        }
        c++;
        if(c > SPI_ESCAPE_LIMIT){
            break;
        }

    }
    return transfer_idx;

}

/* This function is suppose to be in Utils.c file but something is going wrong with it in when kept in the file
 * hence it is kept here.*/
uint16_t Utils_SPI_Receive_Block(mss_spi_instance_t * this_spi, uint8_t * rec_buffer, uint16_t rec_byte_size){
    if(rec_byte_size == 0)
        return 0;

    uint16_t transfer_idx = 0u;
    int16_t tx_idx;
    uint16_t rx_idx;
    uint16_t c;
    uint32_t frame_count;
    uint32_t rx_fifo_empty, tx_fifo_full;uint32_t rx_raw;
    int16_t transit = 0u;

    Utils_SPI_Custom_Setup(this_spi, rec_byte_size);

    tx_idx = 0u; c = 0; rx_idx = 0;uint8_t comp = RX_FIFO_SIZE;
    /* Perform the remainder of the transfer by sending 4 bytes at a time.
     * This should ensure that no Rx overflow can happen in
     * case of an interrupt occurs during this function. */
    while(transfer_idx < rec_byte_size)
    {

        rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
        if(0u == rx_fifo_empty)
        {
            /* Process received byte. */
            rx_raw = this_spi->hw_reg->RX_DATA;

            if(rx_idx < rec_byte_size)
            {
                frame_count = rec_byte_size - rx_idx;
                if(frame_count < RX_FIFO_SIZE){
                    rec_buffer[rx_idx] = rx_raw  & 0xff;
                    ++rx_idx;

                    transfer_idx++;
                }else{
                    rec_buffer[rx_idx] = (rx_raw >> 24) & 0xff;
                    ++rx_idx;
                    rec_buffer[rx_idx] = (rx_raw >> 16) & 0xff;
                    ++rx_idx;
                    rec_buffer[rx_idx] = (rx_raw >> 8) & 0xff;
                    ++rx_idx;
                    rec_buffer[rx_idx] = rx_raw & 0xff;
                    ++rx_idx;
                    comp  = RX_FIFO_SIZE;

                    transfer_idx+=4;
                }
                transit = 0;
            }

        }

        tx_fifo_full = this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK;
        if(0u == tx_fifo_full)
        {
            if(transit == 0)
            {
                if(tx_idx < rec_byte_size)
                {
                    frame_count = rec_byte_size - tx_idx;
                    if(frame_count < RX_FIFO_SIZE){
                        this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
                        this_spi->hw_reg->TXRXDF_SIZE = MSS_SPI_BLOCK_TRANSFER_FRAME_SIZE;
                        this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
                        tx_idx++;
                    }else{
                        tx_idx+=4;
                    }
                    transit = 1;
                    this_spi->hw_reg->TX_DATA = 0x00u;
                }
            }
        }
    }
    return transfer_idx;

}
#endif
