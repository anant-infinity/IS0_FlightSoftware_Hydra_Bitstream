
// All global variables and functions start with capital letter and separated by '_'.

#ifndef _MAIN_SEQ_C
    #define _MAIN_SEQ_C

#include <EPS/eps.h>
#include "Seq_ops/main_seq.h"
#include "CCSDS/ccsds.h"
#include "SD_CARD/sd.h"
#include "RTC/rtc.h"
#include "GPIOs/gpios.h"
#include "Utils/utils.h"
#include "string.h"
#include "Test/test.h"
#include "../../CMSIS/mss_assert.h"
#include "SPI_Flash/spi_flash.h"
#include "SENSOR_BOARD/sensor_board.h"
#include "drivers/mss_uart/mss_uart.h"



void do_nothing() {
	while(1);
}

uint32_t ret_val;
uint8_t sig = 0;
int main(){

//	test_ISO_GPIO_Subsystem_Enable_GPIOs();
//	test_ISO_PeakPower();
//	test_ISO_test_beacon_debug_UART();
//	test_IS0_Read_Sensor_Board_Data();

//	Running the Sequence of Operations
//	main_seq();


}


void main_seq(){

	//Call the Init() function to initialize all the peripherals
	Init();

	Globals.SCIC_SCID_Timer.Start = RTC_Get_Value32();
	Globals.Safe_Pheonix_Timer.Start = RTC_Get_Value32();
	Globals.Sat_Curr_Mode = SC_SCID_MODE;
	Globals.Forced_Mode_Flag = 0x00;

	while(1){

		//Calling the Get Beacon Packet function to collect the data from the EPS and Sensor Boards
		//and storing in Beacon packet structure
		Get_Beacon_Packet();

		//For ground debugging log the beacon packet over UART
		Beacon_Packet_UART_log();

		//Storing the beacon packet in the SD Card
		//TODO: This function is taken as is from IS1 - need to check the working of the same
		//Store_Beacon_Data();

		//TODO: Add code for any interaction with the PSLV UART verilog peripheral if needed.

		//Call the Decide mode function to Apply the forced simulated modes for IS0
		//Decide_Mode();

	}
}

void Init(){

	//Initialize the RTC if required
	int i =  RTC_Enable();

	//Increment the Boot Up Counter
	Globals.Boot_Up_Counter++;

	//Initialize all the GPIOs
	Global_Init_GPIOs();
	//Initialize EPS I2C Channels
	Initialize_EPS_I2C_Channels();
	//Initialize Sensor Board I2C Channel
	Initialize_Sensor_Board_I2C_Channel();


	//Initialize the SD Cards
	//TODO: This fucntion is taken directly from IS1 - Test the working of this function
	SD_Cards_Init();

	//Initialize the PSLV UART IP if required
}



void Get_Beacon_Packet(){

	//TODO Get the important CDH Data

	//Get EPS Data
	Get_EPS_Data();

	//Get VMEL Sensor Board Data
	Get_VEML6075_Data();

	//Get triad sensor data
	Get_AS7265x_Data();

	//Making the beacon packet into CCSDS Format
    CCSDS_Pack( BEACON_PACKET_APID, 0xC0, Globals.Beacon_Packet_Seq_Counter, (struct CCSDS_Header *)&(Beacon_pack_IS0.beac_head), sizeof(Beacon_pack_IS0));
    CCSDS_Fletcher_16((uint8_t *)(&Beacon_pack_IS0), sizeof(Beacon_pack_IS0) - 2);
    Globals.Beacon_Packet_Seq_Counter++;

    }


void Store_Beacon_Data(){
  if (Globals.Current_SD == 0xff) {
	  return;
  }
  uint32_t * write_addr = &Globals.Beacon_Write_Start;
  uint16_t sync = SBAND_SYNC_WORD;
  uint16_t * sync_ptr = &sync;
  uint8_t to_write[sizeof(Beacon_pack_IS0)+SIZEOF_SYNC_WORD];
  memcpy(to_write, (uint8_t *)sync_ptr, SIZEOF_SYNC_WORD);
  memcpy(&to_write[SIZEOF_SYNC_WORD], &Beacon_pack_IS0, sizeof(Beacon_pack_IS0));
  uint32_t i = 0;
  uint8_t tries = 0;
  //try up to 4 times
  while((i < (*write_addr + 1)) && (tries < 4)) {
    i = SD_Write_Data(to_write, sizeof(Beacon_pack_IS0) + SIZEOF_SYNC_WORD, *write_addr, Globals.Current_SD);
    tries++;
  }
  if (tries < 4) {
    //update Write_Start if successful
    *write_addr = (i <= Globals.Beacon_Sector_End) ? i : Globals.Beacon_Sector_Start;
    //TODO: figure out when/how often to update Write_Start flag in flash -- being changed every second
    // how about every time we transmit beacon packet, we update parameter table.
//    if (Globals.Beacon_Packet_Seq_Counter % Beacon_Write_Start_Update_Cnt == 0) {
//    Globals.Indication_Flags |= SAVE_PARAMETER_MAP_FLAG;
//    }
  }
  else {
	  Globals.Current_SD = 0xff;
	  return;
  }

}

void Decide_Mode(){

	//Sequence of Forcing the modes for IS0.
	//The functions to switch mode are written in a way that switching from any mode to any other mode is possible

	//For IS0 mode decision is on the basis of time, following is the description:
	//1. Start in Science D
	//2. Switch between Science D and Science C every 45 minutes
	//3. On 5th day, force into safe mode for 5 orbits - repeat this after 10 days, i.e 5th, 15th, 25th and so on
	//4. On 10th day, force into phoenix mode for 5 orbits - repeat this after 10 days, i.e 10th, 20th, 30th and so on

	//Code to switch between Science C and Science D
	//Psuedo-Code

	//Save initial time - SCI_C and SCI_D mode switch timer
	//If (curr_time - init_time > 45minutes)
	//	If (Curr_mode == Science D)
	//		switch to SCI_D
	//		update init_time
	//	else
	//		switch to SCi_C
	//		update init_time


	Globals.SCIC_SCID_Timer.Time = RTC_Get_Value32();
	if((Globals.SCIC_SCID_Timer.Time - Globals.SCIC_SCID_Timer.Start)>0x0A8C){//45 minutes in hexadecimal is 0x0A8C
		if(Globals.Sat_Curr_Mode == SC_SCID_MODE){
			SwitchTo_Mode_Science_C();
			Globals.SCIC_SCID_Timer.Start = RTC_Get_Value32();
		}
		else{
			SwitchTo_Mode_Science_D();
			Globals.SCIC_SCID_Timer.Start = RTC_Get_Value32();
		}
	}

	//Code to switch to Safe or Phoenix
	//Psuedo-Code

	//Save initial time - Pheonix and Safe mode switch timer
	//If (curr_time - init_time > 5 days)
	//	If (Flag == 0)
	//		switch to Safe
	//		update init_time
	//		flag = 1
	//	else
	//		switch to SCI_C
	//		update init_time
	//		Flag = 0;

	Globals.Safe_Pheonix_Timer.Time = RTC_Get_Value32();
	if((Globals.Safe_Pheonix_Timer.Time - Globals.Safe_Pheonix_Timer.Start)>0x069780){//5 days in hexadecimal is 0x069780

		if(Globals.Forced_Mode_Flag == 0x00){
			SwitchTo_Mode_Safe();
			Globals.Forced_Mode_Flag = 0x01;
			Globals.Safe_Pheonix_Timer.Start = RTC_Get_Value32();
		}
		else{
			SwitchTo_Mode_Pheonix();
			Globals.Forced_Mode_Flag = 0x00;
			Globals.Safe_Pheonix_Timer.Start = RTC_Get_Value32();
		}
	}
}



void SwitchTo_Mode_Science_D(){
	//In science D - DAXSS, SBAND, ADCS, Battery Heater are ON, CIP is OFF
	//This is the mode we star in so turn ON everything except CIP first
	PWR_Switch((GPIO_DSW0_DAXSS_Mask|GPIO_DSW2_ADCS_Mask|GPIO_DSW3_Sband_Mask|GPIO_DSW4_Bat_heat_Mask),1);
	//Turn OFF CIP
	PWR_Switch(GPIO_DSW1_CIP_Mask,0);
}

void SwitchTo_Mode_Science_C(){
	//In science D - CIP, SBAND, ADCS, Battery Heater are ON, DAXSS is OFF
	//turn ON everything except DAXSS first
	PWR_Switch((GPIO_DSW1_CIP_Mask|GPIO_DSW2_ADCS_Mask|GPIO_DSW3_Sband_Mask|GPIO_DSW4_Bat_heat_Mask),1);
	//Turn OFF DAXSS
	PWR_Switch(GPIO_DSW0_DAXSS_Mask,0);

}

void SwitchTo_Mode_Safe(){
	//In Safe mode all the GPIOs Distribution Switches (Subsytem Enables) are OFF, EXCEPT ADCS
	//Turning OFF everything except ADCS
	PWR_Switch((GPIO_DSW0_DAXSS_Mask|GPIO_DSW1_CIP_Mask|GPIO_DSW3_Sband_Mask|GPIO_DSW4_Bat_heat_Mask),0);
	//Turning ON ADCS
	PWR_Switch(GPIO_DSW2_ADCS_Mask,1);
}

void SwitchTo_Mode_Pheonix(){
	//In Pheonix mode all the GPIOs Distribution Switches (Subsytem Enables are OFF)
	//Turning OFF everything
	PWR_Switch((GPIO_DSW0_DAXSS_Mask|GPIO_DSW1_CIP_Mask|GPIO_DSW2_ADCS_Mask|GPIO_DSW3_Sband_Mask|GPIO_DSW4_Bat_heat_Mask),0);
}


void Beacon_Packet_UART_log(){

	uint16_t EPS_array_1[8];
	uint16_t EPS_array_2[8];
	uint16_t EPS_array_3[8];
	uint16_t EPS_array_4[8];

	uint8_t AS7265X_array_1[16];
	uint8_t AS7265X_array_2[16];
	uint8_t AS7265X_array_3[4];


	//Updating the Beacon Packet Structure
	Get_Beacon_Packet();

	//Initializing the MSS UART for Logging
	MSS_UART_init(&g_mss_uart0,MSS_UART_115200_BAUD,MSS_UART_DATA_8_BITS | MSS_UART_NO_PARITY | MSS_UART_ONE_STOP_BIT);

	//Collecting the Data in Arrays to be printed
	uint8_t CCSDS_header_array_1[2] = {Beacon_pack_IS0.beac_head.Version_ID, Beacon_pack_IS0.beac_head.APID };
	uint16_t CCSDS_header_array_2[2] = {Beacon_pack_IS0.beac_head.Seq_no, Beacon_pack_IS0.beac_head.PL};
	uint8_t CCSDS_header_array_3[1] = {Beacon_pack_IS0.beac_head.TS2};
	uint32_t CCSDS_header_array_4[1] = {Beacon_pack_IS0.beac_head.TS1};
	uint16_t CCSDS_fletcher_array[] = {Beacon_pack_IS0.Fletcher_code};

	for(int i = 0; i < 8; ++i){
		EPS_array_1[i] = Beacon_pack_IS0.EPS[i];
	}
	for(int i = 0; i < 8; ++i){
		EPS_array_2[i] = Beacon_pack_IS0.EPS[i+8];
	}
	for(int i = 0; i < 8; ++i){
		EPS_array_3[i] = Beacon_pack_IS0.EPS[i+16];
	}
	for(int i = 0; i < 8; ++i){
		EPS_array_4[i] = Beacon_pack_IS0.EPS[i+24];
	}


	for(int i = 0; i < 16; ++i){
		AS7265X_array_1[i] = Beacon_pack_IS0.Sensor_Board_AS7265X[i];
	}
	for(int i = 0; i < 16; ++i){
		AS7265X_array_2[i] = Beacon_pack_IS0.Sensor_Board_AS7265X[i+16];
	}
	for(int i = 0; i < 4; ++i){
		AS7265X_array_3[i] = Beacon_pack_IS0.Sensor_Board_AS7265X[i+32];
	}

	//Printing the data ussing the MSS UART which can print a maximum of 16 bytes at a time
	//Printing the CCSDS Header
	MSS_UART_polled_tx( &g_mss_uart0, (uint8_t*)CCSDS_header_array_1, sizeof(CCSDS_header_array_1) );
	MSS_UART_polled_tx( &g_mss_uart0, (uint8_t*)CCSDS_header_array_2, sizeof(CCSDS_header_array_2) );
	MSS_UART_polled_tx( &g_mss_uart0, (uint8_t*)CCSDS_header_array_3, sizeof(CCSDS_header_array_2) );
	MSS_UART_polled_tx( &g_mss_uart0, (uint8_t*)CCSDS_header_array_4, sizeof(CCSDS_header_array_4) );

	//Printing the EPS Data
	MSS_UART_polled_tx( &g_mss_uart0, (uint8_t*)EPS_array_1, sizeof(EPS_array_1));
	MSS_UART_polled_tx( &g_mss_uart0, (uint8_t*)EPS_array_2, sizeof(EPS_array_2));
	MSS_UART_polled_tx( &g_mss_uart0, (uint8_t*)EPS_array_3, sizeof(EPS_array_3));
	MSS_UART_polled_tx( &g_mss_uart0, (uint8_t*)EPS_array_4, sizeof(EPS_array_4));
	//Printing the Sensor_Board_VMEL6075 Data
	MSS_UART_polled_tx( &g_mss_uart0, (uint8_t*)Beacon_pack_IS0.Sensor_Board_VMEL6075, sizeof(Beacon_pack_IS0.Sensor_Board_VMEL6075) );

	//Printing the Sensor_Board_AS7265X Data
	MSS_UART_polled_tx( &g_mss_uart0, AS7265X_array_1, sizeof(AS7265X_array_1));

	//Printing the Sensor_Board_AS7265X Data
	MSS_UART_polled_tx( &g_mss_uart0, AS7265X_array_2, sizeof(AS7265X_array_2));

	//Printing the Sensor_Board_AS7265X Data
	MSS_UART_polled_tx( &g_mss_uart0, AS7265X_array_3, sizeof(AS7265X_array_3));

	//Printing the CCSDS Fletcher Code
	MSS_UART_polled_tx( &g_mss_uart0, (uint8_t*)CCSDS_fletcher_array, sizeof(CCSDS_fletcher_array) );

}


void RTC_Sync_Timer_Hanlder(){
  if(Utils_Handle_Timer32_Started(&Globals.RTC_Sync_Timer)){
    Globals.Indication_Flags |= UPDATE_RTC_GPS;
  }
}


void Watchdog_Timer_Handler(){
    if(Utils_Handle_Timer16(&Globals.Watchdog_Signal_Timer, WATCHDOG_SIGNAL_TIMER_FLAG)){
        Watchdog_Pet();
    }
}

void Watchdog_Pet() {
	uint32_t k = (MSS_GPIO_get_outputs() & GPIO_RESET_IC_Mask);
	//toggle k
	k = k == 0;
	MSS_GPIO_set_output(GPIO_RESET_IC, k);
}



void SC_Restart(){
   uint8_t i = 0, j = 0;
   for(i = 0; i < 10; i++){
       j = 0;
       MSS_GPIO_set_output(GPIO_RESET_IC, 0);
       while(j < SC_REBOOT_SIGNAL_DELAY){
           j++;
       }
       MSS_GPIO_set_output(GPIO_RESET_IC, 1);
   }
}


void Utils_SPI_Custom_Setup(mss_spi_instance_t * this_spi, uint16_t frame_count){
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));

    /* This function is only intended to be used with an SPI master. */
    ASSERT((this_spi->hw_reg->CONTROL & CTRL_MASTER_MASK) == CTRL_MASTER_MASK);

    /* Flush the Tx and Rx FIFOs. */
    this_spi->hw_reg->COMMAND |= (TX_FIFO_RESET_MASK | RX_FIFO_RESET_MASK);

    /* Set frame size and the frame count .*/
    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
    this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~TXRXDFCOUNT_MASK) | ( (frame_count << TXRXDFCOUNT_SHIFT) & TXRXDFCOUNT_MASK);
    this_spi->hw_reg->TXRXDF_SIZE = MAX_FRAME_LENGTH;
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;

}


/* This function is suppose to be in Utils.c file but something is going wrong with it in when kept in the file
 * hence it is kept here.*/
uint16_t Utils_SPI_Transmit_Block(mss_spi_instance_t * this_spi, uint8_t * cmd_buffer, uint16_t cmd_byte_size){
    if(cmd_byte_size == 0)
        return 0;

    uint16_t transfer_idx = 0u;
    int16_t tx_idx;
    uint16_t c;
    uint32_t frame_count;
    uint32_t tx_fifo_empty;

    Utils_SPI_Custom_Setup(this_spi, cmd_byte_size);

    tx_idx = 0u;c = 0;
    /* Perform the remainder of the transfer by sending 4 bytes at a time.
     * This should ensure that no Rx overflow can happen in
     * case of an interrupt occurs during this function. */
    while(transfer_idx < cmd_byte_size)
    {

        tx_fifo_empty = this_spi->hw_reg->STATUS & TX_FIFO_EMPTY_MASK;
        if(TX_FIFO_EMPTY_MASK == tx_fifo_empty)
        {
            tx_idx = cmd_byte_size - transfer_idx;
            /* Send another 4 bytes. */
            if(tx_idx >= MAX_FRAME_LENGTH/8)
            {
                this_spi->hw_reg->TX_DATA = Utils_Buffer_to_32_ValueS_Big(&cmd_buffer[transfer_idx]);
                transfer_idx += 4;
            }
            else
            {
                this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
                this_spi->hw_reg->TXRXDF_SIZE = MSS_SPI_BLOCK_TRANSFER_FRAME_SIZE;
                this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;

                this_spi->hw_reg->TX_DATA = cmd_buffer[transfer_idx];
                ++transfer_idx;
            }
            c=0;
            continue;
        }
        c++;
        if(c > SPI_ESCAPE_LIMIT){
            break;
        }

    }
    return transfer_idx;

}

/* This function is suppose to be in Utils.c file but something is going wrong with it in when kept in the file
 * hence it is kept here.*/
uint16_t Utils_SPI_Receive_Block(mss_spi_instance_t * this_spi, uint8_t * rec_buffer, uint16_t rec_byte_size){
    if(rec_byte_size == 0)
        return 0;

    uint16_t transfer_idx = 0u;
    int16_t tx_idx;
    uint16_t rx_idx;
    uint16_t c;
    uint32_t frame_count;
    uint32_t rx_fifo_empty, tx_fifo_full;uint32_t rx_raw;
    int16_t transit = 0u;

    Utils_SPI_Custom_Setup(this_spi, rec_byte_size);

    tx_idx = 0u; c = 0; rx_idx = 0;uint8_t comp = RX_FIFO_SIZE;
    /* Perform the remainder of the transfer by sending 4 bytes at a time.
     * This should ensure that no Rx overflow can happen in
     * case of an interrupt occurs during this function. */
    while(transfer_idx < rec_byte_size)
    {

        rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
        if(0u == rx_fifo_empty)
        {
            /* Process received byte. */
            rx_raw = this_spi->hw_reg->RX_DATA;

            if(rx_idx < rec_byte_size)
            {
                frame_count = rec_byte_size - rx_idx;
                if(frame_count < RX_FIFO_SIZE){
                    rec_buffer[rx_idx] = rx_raw  & 0xff;
                    ++rx_idx;

                    transfer_idx++;
                }else{
                    rec_buffer[rx_idx] = (rx_raw >> 24) & 0xff;
                    ++rx_idx;
                    rec_buffer[rx_idx] = (rx_raw >> 16) & 0xff;
                    ++rx_idx;
                    rec_buffer[rx_idx] = (rx_raw >> 8) & 0xff;
                    ++rx_idx;
                    rec_buffer[rx_idx] = rx_raw & 0xff;
                    ++rx_idx;
                    comp  = RX_FIFO_SIZE;

                    transfer_idx+=4;
                }
                transit = 0;
            }

        }

        tx_fifo_full = this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK;
        if(0u == tx_fifo_full)
        {
            if(transit == 0)
            {
                if(tx_idx < rec_byte_size)
                {
                    frame_count = rec_byte_size - tx_idx;
                    if(frame_count < RX_FIFO_SIZE){
                        this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
                        this_spi->hw_reg->TXRXDF_SIZE = MSS_SPI_BLOCK_TRANSFER_FRAME_SIZE;
                        this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
                        tx_idx++;
                    }else{
                        tx_idx+=4;
                    }
                    transit = 1;
                    this_spi->hw_reg->TX_DATA = 0x00u;
                }
            }
        }
    }
    return transfer_idx;

}
#endif
