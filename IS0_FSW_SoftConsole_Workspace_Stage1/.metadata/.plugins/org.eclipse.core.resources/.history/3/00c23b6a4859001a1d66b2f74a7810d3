#ifndef _SPI_FLASH_C
	#define _SPI_FLASH_C

#include <EPS/eps.h>
#include "spi_flash.h"
#include <stdlib.h>

#include "../mss_spi/mss_spi.h"
#include "../mss_pdma/mss_pdma.h"
#include "../ADCS/adcs.h"
#include "../CCSDS/ccsds.h"
#include "../COMM_TRX_U/uhf.h"
#include "../COMM_TX_S/sband.h"
#include "../Command_handle/command_handle.h"
#include "../DAXSS/daxss.h"
#include "gpios.h"
#include "string.h"

//Module_Sync_Small_t Globals.Param_Module_sync;
//
//uint16_t Globals.Flash_SPI_Wait_Limit = 0x8000;
uint32_t const addresses[8] = {0x00001000, 0x00002000, 0x00003000, 0x00004000,
                            0x00005000, 0x00006000, 0x00007000, 0x0000F000};


void Flash_Init(){

    MSS_SPI_init( &g_mss_spi0 );

    MSS_SPI_configure_master_mode
        (
			&g_mss_spi0,
            MSS_SPI_SLAVE_0,
            MSS_SPI_MODE3,
			FLASH_SPI_CLK_DIV,
            MSS_SPI_BLOCK_TRANSFER_FRAME_SIZE
        );
	uint8_t res = Flash_Read_Status_Register_1();
	if((res & 0x60) != 0){
    	uint8_t cmd = FLASH_CLSR;
		MSS_SPI_set_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
		Flash_CMD(&cmd , 1, 0, 0);
		MSS_SPI_clear_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
	}
	Globals.Flash_SPI_Wait_Limit = 0x8000;

	Globals.Param_Module_sync.CMD_Seq_Count = 0;
	Globals.Param_Module_sync.Prev_CMD_Seq_Count = 0;
	Globals.Param_Module_sync.Response_Read = 0;
	Globals.Param_Module_sync.Response_Length = 0;
}

uint32_t Flash_Wait(){
	uint32_t k=0;uint8_t ready_bit = 0xff;
	do {
		ready_bit =  Flash_Read_Status_Register_1();
		ready_bit = ready_bit & FLASH_STATUS1_WIP;
		k++;
	} while((ready_bit == 1) && k < Globals.Flash_SPI_Wait_Limit);
	return k;
}

void Flash_Write_EN_DIS(uint8_t k){
	MSS_SPI_set_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
	MSS_SPI_transfer_block( &g_mss_spi0, &k, sizeof(uint8_t), 0, 0);
	MSS_SPI_clear_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
}

uint32_t Flash_CMD(uint8_t * cmd, uint8_t cmd_size, uint8_t * rx, uint16_t rx_size){
	uint32_t k;
	if(rx_size==0){
		Flash_Write_EN_DIS(FLASH_WREN);

		MSS_SPI_set_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
		MSS_SPI_transfer_block( &g_mss_spi0, cmd, cmd_size, 0, 0);
		MSS_SPI_clear_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );

		k = Flash_Wait();

		Flash_Write_EN_DIS(FLASH_WRDI);
	}else{
		MSS_SPI_set_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
		MSS_SPI_transfer_block( &g_mss_spi0, cmd, cmd_size, rx, rx_size);
		MSS_SPI_clear_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
		k = Flash_Wait();
	}

	return k;
}

uint8_t Flash_Read_Status_Register_1(){
	MSS_SPI_set_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
	uint8_t ready_bit;
	uint8_t command = FLASH_RDSR1;
	MSS_SPI_transfer_block( &g_mss_spi0, &command, sizeof(command), &ready_bit, sizeof(ready_bit) );
	MSS_SPI_clear_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
	return ready_bit;
}

uint32_t Flash_Erase(uint8_t command, uint32_t address){
	uint8_t cmd[4];
	cmd[0] = command;
	cmd[1] = (address >> 16) & 0xFF;
	cmd[2] = (address >> 8 ) & 0xFF;
	cmd[3] = address & 0xFF;

	if( address > 0x00FFFFFF){
		uint32_t k = Flash_CMD(cmd, 1, 0, 0);
		return k;
	}else{
		uint32_t k = Flash_CMD(cmd, 4, 0, 0);;
		return k;
	}
}

uint32_t Flash_Read_Data(uint32_t address, uint8_t * rx_buffer, uint16_t size_in_bytes){
	uint8_t cmd_buffer[6];
	cmd_buffer[0] = FLASH_READ;
	cmd_buffer[1] = (uint8_t)((address >> 16) & 0xFF);
	cmd_buffer[2] = (uint8_t)((address >> 8) & 0xFF);
	cmd_buffer[3] = (uint8_t)(address & 0xFF);
	cmd_buffer[4] = 0;
	cmd_buffer[5] = 0;
	uint32_t k=0;

    k = Flash_Wait();

    MSS_SPI_set_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
    MSS_SPI_transfer_block( &g_mss_spi0, cmd_buffer, 4, rx_buffer, size_in_bytes );
    MSS_SPI_clear_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );

    k = Flash_Wait();
	return k;
}

uint32_t Flash_write_cmd_data
(
    mss_spi_instance_t * this_spi,
    const uint8_t * cmd_buffer,
    uint16_t cmd_byte_size,
    uint8_t * data_buffer,
    uint16_t data_byte_size
){
    uint8_t tx_buffer[516];
    uint16_t transfer_size;
    uint16_t idx = 0;

    transfer_size = cmd_byte_size + data_byte_size;


    memcpy(tx_buffer, cmd_buffer, cmd_byte_size);
    memcpy(&tx_buffer[cmd_byte_size], data_buffer, data_byte_size);
    MSS_SPI_transfer_block( &g_mss_spi0, tx_buffer, transfer_size, 0, 0 );

    uint32_t k=0;
    while ( !MSS_SPI_tx_done(this_spi) && k < Globals.Flash_SPI_Wait_Limit )
    {
        k++;
    }
    return k;
}

uint32_t Flash_Program(uint32_t address, uint8_t * write_buffer, uint32_t size_in_bytes){

	uint8_t cmd_buffer[4];
	uint32_t k;
	uint32_t in_buffer_idx;
	uint32_t nb_bytes_to_write;
	uint32_t target_addr;
	/**/
	in_buffer_idx = 0;
	nb_bytes_to_write = size_in_bytes;
	target_addr = address;


	while ( in_buffer_idx < size_in_bytes )
	{
		Flash_Write_EN_DIS(FLASH_WREN);
		MSS_SPI_set_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
		uint32_t size_left;
		/* max possible size that can be written to a page. */
		nb_bytes_to_write = 0x100 - (target_addr & 0xFF);
		size_left = size_in_bytes - in_buffer_idx;	// how many bytes are remaining to write
		if ( size_left < nb_bytes_to_write )
		{
			nb_bytes_to_write = size_left;	// if it fits in the page then write size left
		}

		cmd_buffer[0] = FLASH_PP;
		cmd_buffer[1] = (target_addr >> 16) & 0xFF;
		cmd_buffer[2] = (target_addr >> 8 ) & 0xFF;
		cmd_buffer[3] = target_addr & 0xFF;

		k = Flash_write_cmd_data
		  (
			&g_mss_spi0,
			cmd_buffer,
			sizeof(cmd_buffer),
			&write_buffer[in_buffer_idx],
			nb_bytes_to_write
		  );
		k = Flash_Wait();
		target_addr += nb_bytes_to_write;
		in_buffer_idx += nb_bytes_to_write;
		MSS_SPI_clear_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );

		Flash_Write_EN_DIS(FLASH_WRDI);
	}


	return k;
}

uint16_t FLASH_Verify_write(uint8_t* write_buff, uint8_t* read_buff, uint16_t size)
{
    uint16_t index = 0;
    uint16_t counts=0;
    while(size != 0)
    {
        if(write_buff[index] == read_buff[index])
        {
            counts++;
        }
        index++;
        size--;
    }

    return counts;
}

uint16_t FLASH_Verify_write_count(uint8_t* write_buff, uint8_t read_buff, uint16_t size)
{
    uint16_t index = 0;
    uint16_t counts=0;
    while(size != 0)
    {
        if(write_buff[index] == read_buff)
        {
        	counts++;
        }
        index++;
        size--;
    }

    return counts;
}

void Update_Variables(Param_Table_t t){

	Globals.Deps_Wait_Tumb_Flag = t.Param_Deps_Wait_Tumb_Flag;
	Globals.Current_SD = t.Param_Current_SD;


	Globals.PSLV_Wait_Timer.Time = t.Param_PSLV_Wait_Timer_Time;
	Globals.Deployment_Wait_Timer.Time = t.Param_Deployment_Wait_Timer_Time;
	Globals.Deployment_Duration_Timer.Time = t.Param_Deployment_Duration_Timer_Time;
	Globals.HK_Timer.Time = t.Param_HK_Timer_Time;
	Globals.Beac_Timer.Time = t.Param_Beac_Timer_Time;
	Globals.Beac_Trans_Timer.Time = t.Param_Beac_Trans_Timer_Time;
	Globals.ADCS_Pack_Timer.Time = t.Param_ADCS_Pack_Timer_Time;
	Globals.Last_Command_Timer.Time = t.Param_Last_Command_Timer_Time;
	Globals.Watchdog_Signal_Timer.Time = t.Param_Watchdog_Signal_Timer_Time;
	Globals.ADCS_Boot_Wait_Timer.Time = t.Param_ADCS_Boot_Wait_Timer_Time;
	Utils_Reset_Module_Sync(&Globals.ADCS_Module_Sync, ADCS_STATE_BEAC0, t.Param_ADCS_CMD_Timer_Time, t.Param_ADCS_Response_Limit_Timer_Time);
	Utils_Reset_Module_Sync(&Globals.DAXSS_Module_Sync, DAXSS_STATE_BEAC, t.Param_DAXSS_CMD_Timer_Time, t.Param_DAXSS_Response_Limit_Timer_Time);
	Utils_Reset_Module_Sync(&Globals.DAXSS_Response_Module_Sync, 0, t.Param_DAXSS_Response_Timer_Time, 0);
	Utils_Reset_Module_Sync(&Globals.UHF_Module_Sync, UHF_STATE_ECHO_ON, t.Param_UHF_CMD_Timer_Time, t.Param_UHF_Response_Limit_Timer_Time);
	Utils_Reset_Module_Sync(&Globals.EPS_Module_Sync, PWR_STATE_IDLE, t.Param_EPS_CMD_Timer_Time, 0);
	Utils_Reset_Module_Sync(&Globals.SBand_Module_Sync, SBAND_STATE_IDLE, t.Param_SBand_CMD_Timer_Time, 0);
    Globals.DAXSS_Sci_Packet_Timer.Time = t.Param_DAXSS_Sci_Packet_Timer_Time;
    Globals.RTC_Sync_Timer.Time = t.Param_RTC_Sync_Timer_Time;

	Globals.UHF_SC_Restart_Counter = t.Param_UHF_SC_Restart_Counter;
	Globals.UHF_VC_SC_Restart_Counter = t.Param_UHF_VC_SC_Restart_Counter;
	Globals.ADCS_SC_Restart_Counter = t.Param_ADCS_SC_Restart_Counter;
	Globals.ADCS_VC_SC_Restart_Counter = t.Param_ADCS_VC_SC_Restart_Counter;
	Globals.SBAND_SC_Restart_Counter = t.Param_SBAND_SC_Restart_Counter;
	Globals.SBAND_VC_SC_Restart_Counter = t.Param_SBAND_VC_SC_Restart_Counter;
	Globals.DAXSS_SC_Restart_Counter = t.Param_DAXSS_SC_Restart_Counter;
	Globals.DAXSS_VC_SC_Restart_Counter = t.Param_DAXSS_VC_SC_Restart_Counter;
	Globals.Boot_Up_Counter = t.Param_Boot_Up_Counter;
	Beacon_pack.CDH_CMD_Accept_Count = t.Param_CMD_Accept_Count;
	Beacon_pack.CDH_CMD_Reject_Count = t.Param_CMD_Reject_Count;


	Globals.UHF_Malfunction_Flags = t.Param_UHF_Malfunction_Flags;
	Globals.ADCS_Malfunction_Flags = t.Param_ADCS_Malfunction_Flags;
	Globals.SBAND_Malfunction_Flags = t.Param_SBAND_Malfunction_Flags;
	Globals.CMD_Persistant_Flags = t.Param_CMD_Persistant_Flags;
	Globals.DAXSS_Malfunction_Flags = t.Param_DAXSS_Malfunction_Flags;
	Globals.DAXSS_Enable_Wait = t.Param_DAXSS_Enable_Wait;

	Globals.Flash_SPI_Tries_Limit = t.Param_Flash_SPI_Tries_Limit;
	Globals.Flash_SPI_Wait_Limit = t.Param_Flash_SPI_Wait_Limit;
	Globals.Subsystem_Restart_Limit = t.Param_Subsystem_Restart_Limit;
	Globals.SBAND_Auto_Lat_Beac1_i_Limit = t.Param_SBAND_Auto_Lat_Beac1_i_Limit;
	Globals.SBAND_Auto_Lat_Beac1_f_Limit = t.Param_SBAND_Auto_Lat_Beac1_f_Limit;
	Globals.SBAND_Auto_Long_Beac1_i_Limit = t.Param_SBAND_Auto_Long_Beac1_i_Limit;
	Globals.SBAND_Auto_Long_Beac1_f_Limit = t.Param_SBAND_Auto_Long_Beac1_f_Limit;
	Globals.SBAND_Auto_Lat_Data1_i_Limit = t.Param_SBAND_Auto_Lat_Data1_i_Limit;
	Globals.SBAND_Auto_Lat_Data1_f_Limit = t.Param_SBAND_Auto_Lat_Data1_f_Limit;
	Globals.SBAND_Auto_Long_Data1_i_Limit = t.Param_SBAND_Auto_Long_Data1_i_Limit;
	Globals.SBAND_Auto_Long_Data1_f_Limit = t.Param_SBAND_Auto_Long_Data1_f_Limit;
	Globals.SBAND_Auto_Lat_Beac2_i_Limit = t.Param_SBAND_Auto_Lat_Beac2_i_Limit;
	Globals.SBAND_Auto_Lat_Beac2_f_Limit = t.Param_SBAND_Auto_Lat_Beac2_f_Limit;
	Globals.SBAND_Auto_Long_Beac2_i_Limit = t.Param_SBAND_Auto_Long_Beac2_i_Limit;
	Globals.SBAND_Auto_Long_Beac2_f_Limit = t.Param_SBAND_Auto_Long_Beac2_f_Limit;
	Globals.SBAND_Auto_Lat_Data2_i_Limit = t.Param_SBAND_Auto_Lat_Data2_i_Limit;
	Globals.SBAND_Auto_Lat_Data2_f_Limit = t.Param_SBAND_Auto_Lat_Data2_f_Limit;
	Globals.SBAND_Auto_Long_Data2_i_Limit = t.Param_SBAND_Auto_Long_Data2_i_Limit;
	Globals.SBAND_Auto_Long_Data2_f_Limit = t.Param_SBAND_Auto_Long_Data2_f_Limit;
	Globals.Non_Response_Count_Limit = t.Param_Non_Response_Count_Limit;

	Globals.Phoe_Safe_Threshold = t.Param_Phoe_Safe_Threshold;
	Globals.Safe_Phoe_Threshold = t.Param_Safe_Phoe_Threshold;
	Globals.Safe_Char_Threshold = t.Param_Safe_Char_Threshold;
	Globals.Char_Safe_Threshold = t.Param_Char_Safe_Threshold;
	Globals.Char_SciC_Threshold = t.Param_Char_SciC_Threshold;
	Globals.SciC_Char_Threshold = t.Param_SciC_Char_Threshold;
	Globals.Char_SciD_Threshold = t.Param_Char_SciD_Threshold;
	Globals.SciD_Char_Threshold = t.Param_SciD_Char_Threshold;
	Globals.SP_Deployment_Stop_Volt_Threshold = t.Param_SP_Deployment_Stop_Volt_Threshold;
	Globals.De_tumble_Threshold = t.Param_De_tumble_Threshold;
	Globals.ADCS_Eclipse_Threshold = t.Param_ADCS_Eclipse_Threshold;

	memcpy(&Globals.beaconSector, &t.Param_beaconSector, sizeof(SD_Sector_t));
	memcpy(&Globals.scicSector, &t.Param_scicSector, sizeof(SD_Sector_t));
	memcpy(&Globals.scidSector, &t.Param_scidSector, sizeof(SD_Sector_t));
	memcpy(&Globals.adcsSector, &t.Param_adcsSector, sizeof(SD_Sector_t));
	memcpy(&Globals.adcsImgSector, &t.Param_adcsImgSector, sizeof(SD_Sector_t));
	memcpy(&Globals.logSector, &t.Param_logSector, sizeof(SD_Sector_t));
	memcpy(&Globals.hkSector, &t.Param_hkSector, sizeof(SD_Sector_t));

	Globals.SBAND_Encoder_Reg = t.Param_SBAND_Encoder_Reg;

	Globals.CMD_Forced_Mode = t.Param_CMD_Forced_Mode;
	Globals.Force_Mode_Timer.Time = t.Param_Force_Mode_Timer_Time;
	Globals.Force_Mode_Update_Rate.Time = t.Param_Force_Mode_Update_Rate_Time;

	Globals.Last_CMD_Rec.apid = t.Param_Last_CMD_Rec_APID;
	Globals.Last_CMD_Rec.option1 = t.Param_Last_CMD_Rec_option1;
	Globals.Last_CMD_Rec.option2 = t.Param_Last_CMD_Rec_option2;
	Beacon_pack.CDH_CMD_Reject_Status = t.Param_CMD_Reject_Status;
}

//  /* Require Update */
void Load_Factory_Value(){
	Param_Table_t t;

	t.Param_Deps_Wait_Tumb_Flag = 7;
	t.Param_Current_SD = 0;


	t.Param_PSLV_Wait_Timer_Time = 2400000;
	t.Param_Deployment_Wait_Timer_Time = 1800000;
	t.Param_Deployment_Duration_Timer_Time = 60000;
	t.Param_HK_Timer_Time = 30000;
	t.Param_Beac_Timer_Time = 1000;
	t.Param_Beac_Trans_Timer_Time = 10000;
	t.Param_ADCS_Pack_Timer_Time = 30000;
	t.Param_Last_Command_Timer_Time = 172800000;
	t.Param_Watchdog_Signal_Timer_Time = 200;
	t.Param_ADCS_Boot_Wait_Timer_Time = 1000;
	t.Param_ADCS_CMD_Timer_Time = 250;
    t.Param_ADCS_Response_Limit_Timer_Time = 100;
    t.Param_DAXSS_Sci_Packet_Timer_Time = 3500;
    t.Param_DAXSS_CMD_Timer_Time = 400;
    t.Param_DAXSS_Response_Limit_Timer_Time = 100;
    t.Param_DAXSS_Response_Timer_Time = 100;
    t.Param_UHF_CMD_Timer_Time = 700;
    t.Param_UHF_Response_Limit_Timer_Time = 400;
    t.Param_SBand_CMD_Timer_Time = 200;
    t.Param_RTC_Sync_Timer_Time = 60000;
    t.Param_EPS_CMD_Timer_Time = 400;


	t.Param_UHF_SC_Restart_Counter = 0;
	t.Param_UHF_VC_SC_Restart_Counter = 0;
	t.Param_ADCS_SC_Restart_Counter = 0;
	t.Param_ADCS_VC_SC_Restart_Counter = 0;
	t.Param_SBAND_SC_Restart_Counter = 0;
	t.Param_SBAND_VC_SC_Restart_Counter = 0;
	t.Param_DAXSS_SC_Restart_Counter = 0;
	t.Param_DAXSS_VC_SC_Restart_Counter = 0;
	t.Param_Boot_Up_Counter = 0;
	t.Param_CMD_Accept_Count = 0;
	t.Param_CMD_Reject_Count = 0;


	t.Param_UHF_Malfunction_Flags = 0;
	t.Param_ADCS_Malfunction_Flags = 0;
	t.Param_SBAND_Malfunction_Flags = 0;
	t.Param_DAXSS_Malfunction_Flags = 0;
	t.Param_CMD_Persistant_Flags = 0;
	t.Param_DAXSS_Enable_Wait = 1;


	t.Param_Flash_SPI_Tries_Limit = 240;
	t.Param_Flash_SPI_Wait_Limit = 0x8000;
	t.Param_Subsystem_Restart_Limit = 3;
	t.Param_SBAND_Auto_Lat_Beac1_i_Limit = 8.014;
	t.Param_SBAND_Auto_Lat_Beac1_f_Limit = 71.867;
	t.Param_SBAND_Auto_Long_Beac1_i_Limit = 144.265;
	t.Param_SBAND_Auto_Long_Beac1_f_Limit = 66.277;
	t.Param_SBAND_Auto_Lat_Data1_i_Limit = 17.631;
	t.Param_SBAND_Auto_Lat_Data1_f_Limit = 62.316;
	t.Param_SBAND_Auto_Long_Data1_i_Limit = 133.389;
	t.Param_SBAND_Auto_Long_Data1_f_Limit = 77.153;
	t.Param_SBAND_Auto_Lat_Beac2_i_Limit = -21.292;
	t.Param_SBAND_Auto_Lat_Beac2_f_Limit = 24.621;
	t.Param_SBAND_Auto_Long_Beac2_i_Limit = 80.546;
	t.Param_SBAND_Auto_Long_Beac2_f_Limit = 90.106;
	t.Param_SBAND_Auto_Lat_Data2_i_Limit = 12.315;
	t.Param_SBAND_Auto_Lat_Data2_f_Limit = 15.01;
	t.Param_SBAND_Auto_Long_Data2_i_Limit = 90.106;
	t.Param_SBAND_Auto_Long_Data2_f_Limit = 117.26;
	t.Param_Non_Response_Count_Limit = 20;

	t.Param_Phoe_Safe_Threshold = 55;
	t.Param_Safe_Phoe_Threshold = 45;
	t.Param_Safe_Char_Threshold = 70;
	t.Param_Char_Safe_Threshold = 75;
	t.Param_Char_SciC_Threshold = 85;
	t.Param_SciC_Char_Threshold = 80;
	t.Param_Char_SciD_Threshold = 85;
	t.Param_SciD_Char_Threshold = 80;
	t.Param_SP_Deployment_Stop_Volt_Threshold = 10;
	t.Param_De_tumble_Threshold = 1;
	t.Param_ADCS_Eclipse_Threshold = 67.5;

//    t.Param_beaconSector.start = 4;
//    t.Param_beaconSector.end = 31536004;
//    t.Param_scidSector.start = 31536014;
//    t.Param_scidSector.end = 42048014;
//    t.Param_scicSector.start = 42048024;
//    t.Param_scicSector.end = 199728024;
//    t.Param_adcsSector.start = 199728034;
//    t.Param_adcsSector.end = 202881634;
//    t.Param_adcsImgSector.start = 202881644;
//    t.Param_adcsImgSector.end = 202957244;
//    t.Param_logSector.start = 202957254;
//    t.Param_logSector.end = 203503254;
//    t.Param_hkSector.start = 203503274;
//    t.Param_hkSector.end = 203503274;

	t.Param_beaconSector.start = SD_SECTOR_START;
	t.Param_beaconSector.end = t.Param_beaconSector.start + SD_SECTOR_SIZE_BEACON;
	t.Param_scidSector.start = t.Param_beaconSector.end + SD_SECTOR_BUFFER;
	t.Param_scidSector.end = t.Param_scidSector.start + SD_SECTOR_SIZE_SCID;
	t.Param_scicSector.start = t.Param_scidSector.end + SD_SECTOR_BUFFER;
	t.Param_scicSector.end = t.Param_scicSector.start + SD_SECTOR_SIZE_SCIC;
	t.Param_adcsSector.start = t.Param_scicSector.end + SD_SECTOR_BUFFER;
	t.Param_adcsSector.end = t.Param_adcsSector.start + SD_SECTOR_SIZE_ADCS;
	t.Param_adcsImgSector.start = t.Param_adcsSector.end + SD_SECTOR_BUFFER;
	t.Param_adcsImgSector.end = t.Param_adcsImgSector.start + SD_SECTOR_SIZE_IMG;
	t.Param_logSector.start = t.Param_adcsImgSector.end + SD_SECTOR_BUFFER;
	t.Param_logSector.end = t.Param_logSector.start + SD_SECTOR_SIZE_LOG;
	t.Param_hkSector.start = t.Param_logSector.end + SD_SECTOR_BUFFER;
	t.Param_hkSector.end = t.Param_hkSector.start + SD_SECTOR_SIZE_HK;


	t.Param_beaconSector.write = 0;
	t.Param_beaconSector.read = 0;
	t.Param_scidSector.write = 0;
	t.Param_scidSector.read = 0;
	t.Param_scicSector.write = 0;
	t.Param_scicSector.read = 0;
	t.Param_adcsSector.write = 0;
	t.Param_adcsSector.read = 0;
	t.Param_adcsImgSector.write = 0;
	t.Param_adcsImgSector.read = 0;
	t.Param_logSector.write = 0;
	t.Param_logSector.read = 0;
	t.Param_hkSector.write = 0;
	t.Param_hkSector.read = 0;

	t.Param_SBAND_Encoder_Reg = 0;

	t.Param_CMD_Forced_Mode = 0;
    t.Param_Force_Mode_Timer_Time = 0;
    t.Param_Force_Mode_Update_Rate_Time = 0;

    t.Param_Last_CMD_Rec_APID = 0;
	t.Param_Last_CMD_Rec_option1 = 0;
	t.Param_Last_CMD_Rec_option2 = 0;
	t.Param_CMD_Reject_Status = 0;

	t.Param_Fletcher_code = 0;


	Update_Variables(t);
}

void Get_Filled_Array(Param_Table_t * t){
	t->Param_Deps_Wait_Tumb_Flag = Globals.Deps_Wait_Tumb_Flag;
	t->Param_Current_SD = Globals.Current_SD;


	t->Param_PSLV_Wait_Timer_Time = Globals.PSLV_Wait_Timer.Time;
	t->Param_Deployment_Wait_Timer_Time = Globals.Deployment_Wait_Timer.Time;
	t->Param_Deployment_Duration_Timer_Time = Globals.Deployment_Duration_Timer.Time;
	t->Param_HK_Timer_Time = Globals.HK_Timer.Time;
	t->Param_Beac_Timer_Time = Globals.Beac_Timer.Time;
	t->Param_Beac_Trans_Timer_Time = Globals.Beac_Trans_Timer.Time;
	t->Param_ADCS_Pack_Timer_Time = Globals.ADCS_Pack_Timer.Time;
	t->Param_Last_Command_Timer_Time = Globals.Last_Command_Timer.Time;
	t->Param_Watchdog_Signal_Timer_Time = Globals.Watchdog_Signal_Timer.Time;
	t->Param_ADCS_Boot_Wait_Timer_Time = Globals.ADCS_Boot_Wait_Timer.Time;
 	t->Param_ADCS_CMD_Timer_Time = Globals.ADCS_Module_Sync.CMD_Period_Timer.Time;
    t->Param_ADCS_Response_Limit_Timer_Time = Globals.ADCS_Module_Sync.Response_Limit_Timer.Time;
    t->Param_DAXSS_Sci_Packet_Timer_Time = Globals.DAXSS_Sci_Packet_Timer.Time;
    t->Param_DAXSS_CMD_Timer_Time = Globals.DAXSS_Module_Sync.CMD_Period_Timer.Time;
    t->Param_DAXSS_Response_Limit_Timer_Time = Globals.DAXSS_Module_Sync.Response_Limit_Timer.Time;
    t->Param_UHF_CMD_Timer_Time = Globals.UHF_Module_Sync.CMD_Period_Timer.Time;
    t->Param_UHF_Response_Limit_Timer_Time = Globals.UHF_Module_Sync.Response_Limit_Timer.Time;
    t->Param_SBand_CMD_Timer_Time = Globals.SBand_Module_Sync.CMD_Period_Timer.Time;
    t->Param_RTC_Sync_Timer_Time = Globals.RTC_Sync_Timer.Time;


	t->Param_UHF_SC_Restart_Counter = Globals.UHF_SC_Restart_Counter;
	t->Param_UHF_VC_SC_Restart_Counter = Globals.UHF_VC_SC_Restart_Counter;
	t->Param_ADCS_SC_Restart_Counter = Globals.ADCS_SC_Restart_Counter;
	t->Param_ADCS_VC_SC_Restart_Counter = Globals.ADCS_VC_SC_Restart_Counter;
	t->Param_SBAND_SC_Restart_Counter = Globals.SBAND_SC_Restart_Counter;
	t->Param_SBAND_VC_SC_Restart_Counter = Globals.SBAND_VC_SC_Restart_Counter;
	t->Param_DAXSS_SC_Restart_Counter = Globals.DAXSS_SC_Restart_Counter;
	t->Param_DAXSS_VC_SC_Restart_Counter = Globals.DAXSS_VC_SC_Restart_Counter;
	t->Param_Boot_Up_Counter = Globals.Boot_Up_Counter;
	t->Param_CMD_Accept_Count = Beacon_pack.CDH_CMD_Accept_Count;
	t->Param_CMD_Reject_Count = Beacon_pack.CDH_CMD_Reject_Count;

	t->Param_UHF_Malfunction_Flags = Globals.UHF_Malfunction_Flags;
	t->Param_ADCS_Malfunction_Flags = Globals.ADCS_Malfunction_Flags;
	t->Param_SBAND_Malfunction_Flags = Globals.SBAND_Malfunction_Flags;
	t->Param_DAXSS_Malfunction_Flags = Globals.DAXSS_Malfunction_Flags;;
	t->Param_CMD_Persistant_Flags = Globals.CMD_Persistant_Flags;
	t->Param_DAXSS_Enable_Wait = Globals.DAXSS_Enable_Wait;

	t->Param_Flash_SPI_Tries_Limit = Globals.Flash_SPI_Tries_Limit;
	t->Param_Flash_SPI_Wait_Limit = Globals.Flash_SPI_Wait_Limit;
	t->Param_Subsystem_Restart_Limit = Globals.Subsystem_Restart_Limit;
	t->Param_SBAND_Auto_Lat_Beac1_i_Limit = Globals.SBAND_Auto_Lat_Beac1_i_Limit;
	t->Param_SBAND_Auto_Lat_Beac1_f_Limit = Globals.SBAND_Auto_Lat_Beac1_f_Limit;
	t->Param_SBAND_Auto_Long_Beac1_i_Limit = Globals.SBAND_Auto_Long_Beac1_i_Limit;
	t->Param_SBAND_Auto_Long_Beac1_f_Limit = Globals.SBAND_Auto_Long_Beac1_f_Limit;
	t->Param_SBAND_Auto_Lat_Data1_i_Limit = Globals.SBAND_Auto_Lat_Data1_i_Limit;
	t->Param_SBAND_Auto_Lat_Data1_f_Limit = Globals.SBAND_Auto_Lat_Data1_f_Limit;
	t->Param_SBAND_Auto_Long_Data1_i_Limit = Globals.SBAND_Auto_Long_Data1_i_Limit;
	t->Param_SBAND_Auto_Long_Data1_f_Limit = Globals.SBAND_Auto_Long_Data1_f_Limit;
	t->Param_SBAND_Auto_Lat_Beac2_i_Limit = Globals.SBAND_Auto_Lat_Beac2_i_Limit;
	t->Param_SBAND_Auto_Lat_Beac2_f_Limit = Globals.SBAND_Auto_Lat_Beac2_f_Limit;
	t->Param_SBAND_Auto_Long_Beac2_i_Limit = Globals.SBAND_Auto_Long_Beac2_i_Limit;
	t->Param_SBAND_Auto_Long_Beac2_f_Limit = Globals.SBAND_Auto_Long_Beac2_f_Limit;
	t->Param_SBAND_Auto_Lat_Data2_i_Limit = Globals.SBAND_Auto_Lat_Data2_i_Limit;
	t->Param_SBAND_Auto_Lat_Data2_f_Limit = Globals.SBAND_Auto_Lat_Data2_f_Limit;
	t->Param_SBAND_Auto_Long_Data2_i_Limit = Globals.SBAND_Auto_Long_Data2_i_Limit;
	t->Param_SBAND_Auto_Long_Data2_f_Limit = Globals.SBAND_Auto_Long_Data2_f_Limit;
	t->Param_Non_Response_Count_Limit = Globals.Non_Response_Count_Limit;

	t->Param_Phoe_Safe_Threshold = Globals.Phoe_Safe_Threshold;
	t->Param_Safe_Phoe_Threshold = Globals.Safe_Phoe_Threshold;
	t->Param_Safe_Char_Threshold = Globals.Safe_Char_Threshold;
	t->Param_Char_Safe_Threshold = Globals.Char_Safe_Threshold;
	t->Param_Char_SciC_Threshold = Globals.Char_SciC_Threshold;
	t->Param_SciC_Char_Threshold = Globals.SciC_Char_Threshold;
	t->Param_Char_SciD_Threshold = Globals.Char_SciD_Threshold;
	t->Param_SciD_Char_Threshold = Globals.SciD_Char_Threshold;
	t->Param_SP_Deployment_Stop_Volt_Threshold = Globals.SP_Deployment_Stop_Volt_Threshold;
	t->Param_De_tumble_Threshold = Globals.De_tumble_Threshold;
	t->Param_ADCS_Eclipse_Threshold = Globals.ADCS_Eclipse_Threshold;

    memcpy(&t->Param_beaconSector, &Globals.beaconSector, sizeof(SD_Sector_t));
    memcpy(&t->Param_scicSector, &Globals.scicSector, sizeof(SD_Sector_t));
    memcpy(&t->Param_scidSector, &Globals.scidSector, sizeof(SD_Sector_t));
    memcpy(&t->Param_adcsSector, &Globals.adcsSector, sizeof(SD_Sector_t));
    memcpy(&t->Param_adcsImgSector, &Globals.adcsImgSector, sizeof(SD_Sector_t));
    memcpy(&t->Param_logSector, &Globals.logSector, sizeof(SD_Sector_t));
    memcpy(&t->Param_hkSector, &Globals.hkSector, sizeof(SD_Sector_t));

//
//	t->Param_Beacon_Sector_Start = Globals.beaconSector.start;
//	t->Param_Beacon_Sector_End = Globals.beaconSector.end;
//	t->Param_SciD_Sector_Start = Globals.scidSector.start;
//	t->Param_SciD_Sector_End = Globals.scidSector.end;
//	t->Param_SciC_Sector_Start = Globals.scicSector.start;
//	t->Param_SciC_Sector_End = Globals.scicSector.end;
//	t->Param_ADCS_Sector_Start = Globals.adcsSector.start;
//	t->Param_ADCS_Sector_End = Globals.adcsSector.end;
//	t->Param_ADCS_Image_Sector_Start = Globals.adcsImgSector.start;
//	t->Param_ADCS_Image_Sector_End = Globals.adcsImgSector.end;
//	t->Param_Log_Sector_Start = Globals.logSector.start;
//	t->Param_Log_Sector_End = Globals.logSector.end;
//	t->Param_HK_Sector_Start = Globals.hkSector.start;
//	t->Param_HK_Sector_End = Globals.hkSector.end;
//
//
//	t->Param_Beacon_Write_Start = Globals.beaconSector.write;
//	t->Param_Beacon_Read_Start = Globals.beaconSector.read;
//	t->Param_SciC_Write_Start = Globals.scicSector.write;
//	t->Param_SciC_Read_Start = Globals.scicSector.read;
//	t->Param_SciD_Write_Start = Globals.scidSector.write;
//	t->Param_SciD_Read_Start = Globals.scidSector.read;
//	t->Param_ADCS_Write_Start = Globals.adcsSector.write;
//	t->Param_ADCS_Read_Start = Globals.adcsSector.read;
//	t->Param_ADCS_Image_Write_Start = Globals.adcsImgSector.write;
//	t->Param_ADCS_Image_Read_Start = Globals.adcsImgSector.read;
//	t->Param_Log_Write_Start = Globals.logSector.write;
//	t->Param_Log_Read_Start = Globals.logSector.read;
//	t->Param_HK_Write_Start = Globals.hkSector.write;
//	t->Param_HK_Read_Start = Globals.hkSector.read;

	t->Param_SBAND_Encoder_Reg = Globals.SBAND_Encoder_Reg;

	t->Param_CMD_Forced_Mode = Globals.CMD_Forced_Mode;
    t->Param_Force_Mode_Timer_Time = Globals.Force_Mode_Timer.Time;
    t->Param_Force_Mode_Update_Rate_Time = Globals.Force_Mode_Update_Rate.Time;

    t->Param_Last_CMD_Rec_APID = Globals.Last_CMD_Rec.apid;
	t->Param_Last_CMD_Rec_option1 = Globals.Last_CMD_Rec.option1;
	t->Param_Last_CMD_Rec_option2 = Globals.Last_CMD_Rec.option2;
	t->Param_CMD_Reject_Status = Beacon_pack.CDH_CMD_Reject_Status;

}

// TODO: add handle for triple parameter table implementation
uint8_t Save_Parameter_Table(){
	if(Globals.Param_Module_sync.CMD_Seq_Count == FLASH_STATE_IDLE){
		return FLASH_STATE_IDLE;
	}
    Param_Table_t FLASH_Parameter_Arr;
	Get_Filled_Array(&FLASH_Parameter_Arr);
    CCSDS_Fletcher_16((uint8_t *)&FLASH_Parameter_Arr, sizeof(FLASH_Parameter_Arr)-2);

    uint8_t res = Save_Parameter_Table_Arr((uint8_t *)&FLASH_Parameter_Arr, sizeof(FLASH_Parameter_Arr), addresses[7]);
    if(res == 0xff){
    	if(Globals.Param_Module_sync.Response_Read  < Globals.Flash_SPI_Tries_Limit){
    		Globals.Param_Module_sync.Response_Read++;
    		/* Send the clear status command */
    		uint8_t cmd[] = {FLASH_CLSR};
    		MSS_SPI_transfer_block(&g_mss_spi0, cmd, sizeof(cmd), 0, 0);	/* Check it once */
    		Globals.Param_Module_sync.CMD_Seq_Count = FLASH_STATE_ERASE_CMD;
    		return 0xff;
    	}
    	else{
    		Globals.Param_Module_sync.CMD_Seq_Count = FLASH_STATE_IDLE;
    		return 0x00;
    	}
    }else if(res == FLASH_STATE_PROGRAM){
    	Globals.Param_Module_sync.Response_Read = 0;
    	return 0x01;
    }else{
    	return 0x02;
    }
}

uint8_t Save_Parameter_Table_Arr(uint8_t * FLASH_Parameter_Arr, uint16_t FLASH_Parameter_Arr_Size, uint32_t address){
    uint8_t rx_buff[FLASH_Parameter_Arr_Size];
    uint32_t status=0;
    uint8_t ready_bit = 0xff; uint8_t cmd[4];
	switch(Globals.Param_Module_sync.CMD_Seq_Count){
		case FLASH_STATE_ERASE_CMD:	/* Sector erase command */
			Globals.Param_Module_sync.Response_Length = 0;
			cmd[0] = FLASH_P4E;
			cmd[1] = (address >> 16) & 0xFF;
			cmd[2] = (address >> 8 ) & 0xFF;
			cmd[3] = address;
			Flash_Write_EN_DIS(FLASH_WREN);
			MSS_SPI_set_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );
			MSS_SPI_transfer_block( &g_mss_spi0, cmd, sizeof(cmd), 0, 0);
			MSS_SPI_clear_slave_select( &g_mss_spi0, MSS_SPI_SLAVE_0 );

    		Globals.Param_Module_sync.CMD_Seq_Count = FLASH_STATE_WAIT;
    		Globals.Param_Module_sync.Prev_CMD_Seq_Count = FLASH_STATE_ERASE_CMD;
    		return FLASH_STATE_ERASE_CMD;

    	case FLASH_STATE_WAIT:	/* Wait state for erase (only) */
    		ready_bit =  Flash_Read_Status_Register_1();
			ready_bit = ready_bit & FLASH_STATUS1_WIP;
			Globals.Param_Module_sync.Prev_CMD_Seq_Count = FLASH_STATE_WAIT;
			if(ready_bit == 0){
				Globals.Param_Module_sync.CMD_Seq_Count = FLASH_STATE_ERASE_VERIFY;
    			Flash_Write_EN_DIS(FLASH_WRDI);
    			return FLASH_STATE_WAIT;
			}else{
				Globals.Param_Module_sync.CMD_Seq_Count = FLASH_STATE_WAIT;
				Globals.Param_Module_sync.Response_Length++;
				if(Globals.Param_Module_sync.Response_Length >= Globals.Flash_SPI_Wait_Limit){
					Flash_Write_EN_DIS(FLASH_WRDI);
					return 0xff;
				}else{
					return FLASH_STATE_WAIT;
				}
			}
    		break;

    	case FLASH_STATE_ERASE_VERIFY:	/* Cross check the erase */
    		status = Flash_Read_Data(address, rx_buff, FLASH_Parameter_Arr_Size);
	        status = FLASH_Verify_write_count(rx_buff, 0xff, FLASH_Parameter_Arr_Size);
	        Globals.Param_Module_sync.CMD_Seq_Count = FLASH_STATE_PROGRAM;
    		Globals.Param_Module_sync.Prev_CMD_Seq_Count = FLASH_STATE_ERASE_VERIFY;
	        if(status != FLASH_Parameter_Arr_Size){
	        	return 0xff;
	        }else{
	        	return FLASH_STATE_ERASE_VERIFY;
	        }

	    case FLASH_STATE_PROGRAM:	/* Program the sector and cross check */
	    	status = Flash_Program(address, FLASH_Parameter_Arr, FLASH_Parameter_Arr_Size);
	        status = Flash_Read_Data(address, rx_buff, FLASH_Parameter_Arr_Size);
	        status = FLASH_Verify_write(rx_buff, FLASH_Parameter_Arr, FLASH_Parameter_Arr_Size);

			Globals.Param_Module_sync.CMD_Seq_Count = FLASH_STATE_IDLE;
			Globals.Param_Module_sync.Prev_CMD_Seq_Count = FLASH_STATE_PROGRAM;
	        if(status != FLASH_Parameter_Arr_Size){
				return 0xff;
	        }else{
	            return FLASH_STATE_PROGRAM;
	        }

	    default:	/* IDLE state */
	    	return FLASH_STATE_IDLE;
	}
}

uint8_t Load_Parameter_Table(){
	Param_Table_t FLASH_Parameter;
	if(Read_Parameter_Table(&FLASH_Parameter)){
		Update_Variables(FLASH_Parameter);
		return 1;
	}

	Load_Factory_Value();
	return 0;
}


// TODO: add handle for triple parameter table implementation
uint8_t Read_Parameter_Table(Param_Table_t * FLASH_Parameter){

	int8_t i=7; uint32_t status; uint8_t reading_errors = 0;
	uint16_t FLASH_Parameter_Arr_Size = sizeof(Param_Table_t);
	while(i > 6){
		status = Flash_Read_Data(addresses[i], (uint8_t *)FLASH_Parameter, FLASH_Parameter_Arr_Size);
		if(status < Globals.Flash_SPI_Wait_Limit){
        	status = CCSDS_Fletcher_16_Checkbytes((uint8_t *)FLASH_Parameter, FLASH_Parameter_Arr_Size, 0);
			if(status == 0){
				// Update_Variables(FLASH_Parameter);
				return 1; 	/* The "break" means we won't be correcting the corrupted sectors.*/
			}
        }
		i--;
	}
	return 0;
}

#endif
