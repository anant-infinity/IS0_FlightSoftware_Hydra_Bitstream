/*
 * main_sch.h
 *
 *  Created on: Jul 9, 2018
 *      Author: Ankit
 */
/*
 * // Default Flags order:
 * 1st bit - UHF
 * 2th bit - ADCS
 * 3th bit - SBAND
 * 4th bit - CIP
 * 5th bit - EPS
 * 6th bit - CDH
 * 7th bit - DAXSS
 */
#ifndef _MAIN_SEQ_H
#define _MAIN_SEQ_H

/***  defines for code state    **********/
#define ENABLE_UART0_COMMAND
#define TEST_STATE // TODO: remove before flight
/***************************/

/***
 * Defines for which FPGA configuration we are running!
 */
//#define ANKIT_OLD_AND_WORKING
//#define MAYURESH_V3_RTC_WORKS
//#define MAYURESH_V4_DOESNT_WORK
#define MAYURESH_V4			// as of 10/22/2019 --  clock tree didn't match in C and in FPGA
/********************************/



#include "CortexM3/GNU/cpu_types.h"
#include "mss_spi/mss_spi.h"

#undef  GLOBAL
#ifdef _MAIN_SEQ_C
#define GLOBAL
#else
#define GLOBAL extern
#endif

/*************************************************************************/
/* Some general definitions*/

#define SC_REBOOT_SIGNAL_DELAY	240 		// Number of cycles which will be given between each toggle of the line going to the 4 bit counter IC.
#define PI 						(22/7) 		// The value of PI
#define SPI_ESCAPE_LIMIT		0xff00 		// The counter value to escape the loop in the SPI transactions
#define CCSDS_MAX_DATA_SIZE 	243			// the maximum size of the data that can be put into one CCSDS packet with AX.25 around it. After adding the CCSDS header and the fletcher code
											// the size of the packet becomes 256 bytes.

/*************************************************************************/

/* Defining the APIDs of different packet */
#define  BEACON_PACKET_APID                     0x10

/*************************************************************************/

/* Defining the modes of operation of the spacecraft */
#define SC_PHOENIX_MODE     0x00
#define SC_SAFE_MODE        0x01
//Removed charging mode for IS0
//#define SC_CHARGING_MODE    0x02
#define SC_SCIC_MODE        0x03
#define SC_SCID_MODE        0x04
/*************************************************************************/



/* Globals.Timers_Started_Flag */

#define BEAC_TIMER_STARTED_FLAG					0x010
#define BEAC_TRANS_TIMER_STARTED_FLAG			0x020
#define WATCHDOG_SIGNAL_TIMER_FLAG               0x100

/*************************************************************************/

/* Indication Flags: Indication_Flags */
#define SAVE_PARAMETER_MAP_FLAG     	0x0001
#define SD_CARD0_WORKING            	0x0002
#define SD_CARD1_WORKING            	0x0004
#define SC_REBOOT                   	0x0020
#define IS_ECLIPSE                  	0x0040
#define REQ_BEACON_TRANSMIT         	0x1000
#define REQ_SD_DATA_TRANSMIT        	0x4000

/*************************************************************************/

/* Data Valid Flags: Beac_pack.CDH_Sub_System_Data_Valid_Flags */

#define EPS_C0_DATA_VALID_FLAG	0x10
#define EPS_C1_DATA_VALID_FLAG	0x20
#define EPS_NC_DATA_VALID_FLAG	0x40
#define EPS_DATA_VALID_FLAG		0x10
/*************************************************************************/


/* Packet Sizes (including CCSDS Headers) */
#define CCSDS_TLM_WRAPPER_SIZE			13
#define BEACON_PACKET_SIZE				254
#define PARAMETER_TABLE1_PACKET_SIZE 	256
#define PARAMETER_TABLE2_PACKET_SIZE	94



/***************************** Global Variables ***************************************************/

GLOBAL uint64_t statusG; 	// a global Variable for looking at the return values of various functions. It is used only in main.c file (See main.c file)


/********************************* Global Variable Ends ***********************************************/

/*---------------------------------------------------------------------------*/
/* The main_seq() is the main sequence of operation. Call this function in the
 * main() function to run the flight software.
 *
 * @param
 * 	No parameter
 *
 * @return: void
 *
*/
void main_seq();

/*---------------------------------------------------------------------------*/
/* The Init() initializes all the modules of the flight software. It also reads
 * the parameter table from the flash memory and updates all the variables
 * appropriately.
 *
 * @param
 * 	No parameter
 *
 * @return: void
 *
*/
void Init();

/*---------------------------------------------------------------------------*/
/* The Get_Beacon_Packet() function forms the beacon packet structure by collecting
 * data from the sensor board and EPS. It also forms the CCSDS version of the packet
 * by added the CCSDS Header and fletcher code
 *
 * @param
 * 	No parameter
 *
 * @return: void
 *
*/
void Get_Beacon_Packet();

/*---------------------------------------------------------------------------*/
/* The Store_Beacon_Data() stores the beacon packet in appropriate SD card
 * and put the request to save the parameter table. If the write operation fails
 * it sets the Current SD card to 0xff indicating the failure of the SD card.
 *
 * This function is under development.
 *
 * @param
 * 	No parameter
 *
 * @return: void
 *
*/
void Store_Beacon_Data();


/*---------------------------------------------------------------------------*/
/* The Decide_Mode() decides the mode of the spacecraft. This
 * is called either at the beginning or at the end of the sequence of operation.
 * It decides the mode on the basis of two timer values, one for SCIC and SCID
 * and the other for Safe and Pheonix
 *
 * @param
 * 	No parameter
 *
 * @return: void
 *
*/
void Decide_Mode();

void SwitchTo_Mode_Science_C();
void SwitchTo_Mode_Science_D();
void SwitchTo_Mode_Safe();
void SwitchTo_Mode_Pheonix();

/*---------------------------------------------------------------------------*/
/* The Beacon_Packet_UART_log() is used for ground testing only. It uss MSS_UART_0
 * To transimit the beacon packet formed to a ground PC.
 *
 * @param
 * 	No parameter
 *
 * @return: void
 *
*/
void Beacon_Packet_UART_log();



/*---------------------------------------------------------------------------*/
/* The Watchdog_Timer_Handler() manages the Watchdog timer. Once it expires then
 * a signal to the external watchdog IC is sent and the timer is restarted.
 *
 * @param
 * 	No parameter
 *
 * @return: void
 *
*/
void Watchdog_Timer_Handler();

void Watchdog_Pet(void);


/*---------------------------------------------------------------------------*/
/* The SC_Restart() does the spacecraft restart. It has to give 8 positive edges
 * on a GPIO line going to the external 4-bit counter IC on-board. It sets the 
 * GPIO low then give a delay of SC_REBOOT_SIGNAL_DELAY cycles using for loop
 * then sets the GPIO high. Repeat the process 8 times and the spacecraft should
 * get restarted before or on the 8th cycle.
 *
 * @param
 * 	No parameter
 *
 * @return: void
 *
*/
void SC_Restart();



/*---------------------------------------------------------------------------*/
/* The Utils_SPI_Custom_Setup() sets up the SPI for the transaction of data.
 *
 * @param
 * 	No parameter
 *
 * @return: void
 *
*/
void Utils_SPI_Custom_Setup(mss_spi_instance_t * this_spi, uint16_t frame_count);

/*---------------------------------------------------------------------------*/
/* The Utils_SPI_Transmit_Block() transmits block of data.
 *
 * @param
 * 	No parameter
 *
 * @return: void
 *
*/
uint16_t Utils_SPI_Transmit_Block(mss_spi_instance_t * this_spi, uint8_t * cmd_buffer, uint16_t cmd_byte_size);

/*---------------------------------------------------------------------------*/
/* The Utils_SPI_Receive_Block() receives the block of data.
 *
 * @param
 * 	No parameter
 *
 * @return: void
 *
*/
uint16_t Utils_SPI_Receive_Block(mss_spi_instance_t * this_spi, uint8_t * rec_buffer, uint16_t rec_byte_size);


#pragma pack(1)	// this pragma makes sure that all the structs are tightly packed



struct CCSDS_Header{	// The CCSDS header struct
        uint8_t Version_ID;
        uint8_t APID;
        uint16_t Seq_no;
        uint16_t PL;
        uint8_t TS2;    /* 1 lSB byte */
        uint32_t TS1;   /* 4 byte of MSB */
};

typedef enum BeaconEpsPacketEnum {
    EPS_Bat_Volt = 0,
    EPS_Bat_Curr,
    EPS_Bus_Volt,
    EPS_Bus_Curr,
    EPS_Bat_SOC,
    EPS_Bat_Temp1,
    EPS_Bat_Temp2,
    EPS_SP1_Volt,
    EPS_SP2_Volt,
    EPS_SP3_Volt,

    EPS_SP1_Curr,
    EPS_SP2_Curr,
    EPS_SP3_Curr,
    EPS_Interface_Temp,
    EPS_EPS_Temp,
    EPS_CIP_Volt,
    EPS_CIP_Curr,
    EPS_ADCS_Volt,
    EPS_ADCS_Curr,
    EPS_SBAND_Volt,

    EPS_SBAND_Curr,
    EPS_UHF_Volt,
    EPS_UHF_Curr,
    EPS_CDH_Volt,
    EPS_CDH_Curr,
    EPS_GPS_33_Volt,
    EPS_GPS_33_Curr,
    EPS_GPS_12_Volt,
    EPS_GPS_12_Curr,
    EPS_Bat_Heater_Curr,

    EPS_DAXSS_Volt,
    EPS_DAXSS_Curr,
} BeaconEpsPacket;

typedef enum BeaconVMEL6075PacketEnum {
	VMEL6075_UVA_DATA = 0,
	VMEL6075_UVB_DATA,
	VMEL6075_UVCOMP1_DATA,
	VMEL6075_UVCOMP2_DATA,

}BeaconVMEL6075Packet;


struct Beacon_packet_IS0{
	//To Add CCSDS Header
    struct CCSDS_Header beac_head;	// The CCSDS header

    //To Add CDH HK Data
    //uint8_t CDH_Subsystem_ON_Stat;
    //uint16_t CDH_Temp;
    //uint8_t CDH_Primary_Info;
    //uint8_t CDH_Sub_System_Data_Valid_Flags;

    //EPS HK Data
    uint16_t EPS[32];

    //Sensor Board VMEL Data
    uint16_t Sensor_Board_VMEL6075[4];
    //TODO: Update the hydra code to combine DATA_L and DATA_H

    //Sensor Board AS7265X Data
    uint8_t Sensor_Board_AS7265X[36];

    //To Add the Fletcher Code
    uint16_t Fletcher_code;


} Beacon_pack_IS0;




typedef struct Parameter_Table 	// The stuct definition for all the variables which are in the parameter table.
{
	//Simply modified the IS1 Parameter table - Removed all the variables that seemed to be useless for IS0
	//Currently these parameters are not used in IS0, need to
    uint8_t Param_Current_SD;
    /* Timer data */
    uint32_t Param_Beac_Timer_Time;
    uint32_t Param_Beac_Trans_Timer_Time;
    uint16_t Param_Watchdog_Signal_Timer_Time;
    uint32_t Param_RTC_Sync_Timer_Time;

    /* Counters */
    uint32_t Param_Boot_Up_Counter;

    /* Flags */
    uint8_t Param_UHF_Malfunction_Flags;
    uint8_t Param_ADCS_Malfunction_Flags;

    /* Limits */
    uint8_t Param_Flash_SPI_Tries_Limit;
    uint16_t Param_Flash_SPI_Wait_Limit;
    uint8_t Param_Non_Response_Count_Limit;

    /* Thresholds */
    uint16_t Param_Phoe_Safe_Threshold;
    uint16_t Param_Safe_Phoe_Threshold;
    uint16_t Param_Safe_Char_Threshold;
    uint16_t Param_Char_Safe_Threshold;
    uint16_t Param_Char_SciC_Threshold;
    uint16_t Param_SciC_Char_Threshold;
    uint16_t Param_Char_SciD_Threshold;
    uint16_t Param_SciD_Char_Threshold;


    /* SD card data */
    uint32_t Param_Beacon_Sector_Start;
    uint32_t Param_Beacon_Sector_End;


    /* Write and transmit data indicators */
    uint32_t Param_Beacon_Write_Start;
    uint32_t Param_Beacon_Read_Start;

    /* Persistent commands data*/
    uint8_t Param_CMD_Forced_Mode;
    uint32_t Param_Force_Mode_Timer_Time;
    uint32_t Param_Force_Mode_Update_Rate_Time;

    uint16_t Param_EPS_CMD_Timer_Time;
    uint16_t Param_Fletcher_code;

} Param_Table_t;


struct CCSDS_Max_Data_size_Packet	// Definition of a general packet containing the maximum data size array
{
    struct CCSDS_Header ccsds_head;	// the ccsds header 

    uint8_t data[CCSDS_MAX_DATA_SIZE];	// the array with maximum data size allowed

    uint16_t Fletcher_code;
};

typedef struct CCSDS_Max_Data_size_Packet Param_table_packet1_t;	// typedef the CCSDS Max size packet as the Paramter table packet1

typedef struct Parameter_Table_Packet{ // the struct definition of the second parameter table packet

    struct CCSDS_Header param_head;	// the CCSDS header

    uint8_t data[sizeof(Param_Table_t)];

    uint16_t Fletcher_code;

} Param_table_packet2_t;



/* Structs for Timers */
typedef struct Timer64 {
	uint64_t Start;
	uint64_t Time;
} Timer64_t;

typedef struct Timer32{
	uint32_t Start;
	uint32_t Time;
} Timer32_t;

typedef struct Timer16{
	uint16_t Start;
	uint16_t Time;
} Timer16_t;

typedef struct Derek_Timer16 {
	uint16_t start;
	uint16_t time;
	uint8_t isStarted;
}Derek_Timer16_t;

typedef struct Timer8{
	uint8_t Start;
	uint8_t Time;
} Timer8_t;

typedef struct 	// a small struct for the managing the less complex state machines.
{
    uint16_t CMD_Seq_Count;
    uint16_t Prev_CMD_Seq_Count;
    uint16_t Response_Length;
    uint16_t Response_Read;
} Module_Sync_Small_t;


GLOBAL struct Global_Variables { 	// Struct containing all the global variables
   uint8_t                     	Forced_Mode_Flag;
   Timer32_t                   	SCIC_SCID_Timer;
   Timer32_t					Safe_Pheonix_Timer;
   Timer32_t                   	Force_Mode_Update_Rate;
   Timer16_t                   	DAXSS_Sci_Packet_Timer;
   uint8_t                     	I2C_Error_Flag;
   uint8_t                     	Sat_Curr_Mode;
   uint8_t                     	Sat_Avoid_Mode;
   uint32_t                    	Timers_Started_Flag;
   uint32_t                    	Indication_Flags;
   uint16_t                    	Beacon_Packet_Seq_Counter;
   uint16_t                    	Science_Packet_Seq_Counter;
   Timer32_t                   	Beac_Timer;
   Timer32_t                   	Beac_Trans_Timer;
   Timer16_t                   	Watchdog_Signal_Timer;
   Timer32_t                   	RTC_Sync_Timer;
   uint8_t                     	Non_Response_Count_Limit;
   uint8_t                     	Subsystem_Restart_Limit;
   uint16_t                    	Phoe_Safe_Threshold;
   uint16_t                    	Safe_Phoe_Threshold;
   uint16_t                    	Safe_Char_Threshold;
   uint16_t                    	Char_Safe_Threshold;
   uint16_t                   	Char_SciD_Threshold;
   uint16_t                    	SciD_Char_Threshold;
   uint16_t                    	Char_SciC_Threshold;
   uint16_t                    	SciC_Char_Threshold;
   uint8_t                     	Flash_SPI_Tries_Limit;
   uint8_t                     	CMD_Persistant_Flags;
   uint32_t                    	Boot_Up_Counter;
   uint32_t                    	Beacon_Sector_Start;
   uint32_t                    	Beacon_Sector_End;
   uint32_t                    	Beacon_Write_Start;
   uint32_t                    	Beacon_Read_Start;
   uint32_t                    	HK_Read_Start;
   uint8_t                     	PWR_I2C_Error_Count[3];
   uint16_t                    	PWR_Fuel_Guage_Data[3];
   uint16_t                    	Flash_SPI_Wait_Limit;
   uint8_t                     	SD_Clk_Div;
   uint8_t                     	Current_SD;
   uint16_t 					Globals_Table_Packet_Seq_Counter;
   Module_Sync_Small_t			SD_FDRI_Module_Sync;
} Globals;


typedef struct CCSDS_Max_Data_size_Packet Global_packet_Full_t;	// Tyepdef of the CCSDS Max size packet as global packet 1
typedef struct Global_Table_Packet{	// Struct definition of last global packet 

    struct CCSDS_Header global_head;	// the CCSDS header

    uint8_t data[sizeof(Globals)];

    uint16_t Fletcher_code;

} Global_packet_Last_t;


#endif /* MAIN_SCH_H_ */
