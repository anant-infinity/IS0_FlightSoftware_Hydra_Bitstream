
// All global variables and functions start with capital letter and separated by '_'.

#ifndef _MAIN_SEQ_C
    #define _MAIN_SEQ_C

#include <EPS/eps.h>
#include "Seq_ops/main_seq.h"
#include "CCSDS/ccsds.h"
#include "SD_CARD/sd.h"
#include "Command_handle/command_handle.h"
#include "RTC/rtc.h"
#include "gpios.h"
#include "UART/UART_RX_V3.h"
#include "UART/UART_TX.h"
#include "Utils/utils.h"
#include "string.h"
#include "Test/test.h"
#include "../../CMSIS/mss_assert.h"
#include "SPI_Flash/spi_flash.h"


//****************** Headers Used in IS1 ***************\\

#include "DAXSS/daxss.h"
#include "COMM_TRX_U/uhf.h"
#include "COMM_TRX_U/uhf_tx.h"
#include "COMM_TX_S/sband.h"
#include "CIP/cip.h"
#include "ADCS/adcs.h"



void do_nothing() {
	while(1);
}

uint32_t ret_val;
uint8_t sig = 0;
int main(){


//	test_ISO_GPIO_Subsystem_Enable_GPIOs();
//	test_ISO_PeakPower();
	test_ISO_test_beacon_debug_UART();
	test_IS0_Read_Sensor_Board_Data();

//	test4_ISO_PeakPower();


}

//TODO: check to see all the timers are updated in the param table AND HYDRA!

void main_seq(){

	Init();

    Globals.RTC_Sync_Timer.Start = RTC_Get_Value32();
    Globals.Sat_Curr_Mode = SC_CHARGING_MODE; /* Setting the current mode to phoenix mode */


    while(1){
//        PWR_Switch(GPIO_DSW0_DAXSS_Mask, sig);
        sig = !sig;
        Configure_EPS_Slaves(); /* Should this be called in every loop? */


        if((Globals.Indication_Flags & SAVE_PARAMETER_MAP_FLAG) > 0){
            if(Globals.Param_Module_sync.CMD_Seq_Count == FLASH_STATE_IDLE){
                Globals.Param_Module_sync.CMD_Seq_Count = FLASH_STATE_ERASE_CMD;
            }
        }

        statusG = Save_Parameter_Table();

        if(statusG == FLASH_WRITE_FAIL){
        /*TODO:  Unable to update the parameter table. Log it*/
            Globals.Indication_Flags &= (~SAVE_PARAMETER_MAP_FLAG);
        }else if(statusG == FLASH_WRITE_SUCCESS || statusG == FLASH_WRITE_IDLE){
            Globals.Indication_Flags &= (~SAVE_PARAMETER_MAP_FLAG);
            if((Globals.Indication_Flags & SC_REBOOT) > 0){
                Globals.Indication_Flags &= (~SC_REBOOT);
//                SC_Restart();
            }
        }


        HK_Timer_Handler();

        Watchdog_Timer_Handler();

        RTC_Sync_Timer_Hanlder();

//      Read_EPS_Data();    /* Reading the required data */


        Handle_Power_Supply();

        if(((Globals.Timers_Started_Flag & ADCS_BOOT_WAIT_TIMER_STARTED) == 0) && (Globals.Sat_Curr_Mode != SC_PHOENIX_MODE)){
            Globals.ADCS_Boot_Wait_Timer.Start = RTC_Get_Value16();
            Globals.Timers_Started_Flag |= ADCS_BOOT_WAIT_TIMER_STARTED;
        }

        if(((Globals.Timers_Started_Flag & ADCS_BOOT_WAIT_TIMER_STARTED) && Utils_Handle_Timer16_Started(&Globals.ADCS_Boot_Wait_Timer)) || ((Globals.Indication_Flags & ADCS_BOOT_WAIT_COMPLETED) > 0)){
          ADCS_Seqs();
          ADCS_Response_Handler();
          Globals.Indication_Flags |= ADCS_BOOT_WAIT_COMPLETED;
        }


        CMD_Poll_CMD();

        #ifdef ENABLE_UART0_COMMAND
        CMD_Pool_For_UART0_CMD();
        #endif

        CMD_Continued_Execution();

        Beacon_Timer_Handler();
        Beacon_Transmit_Timer_Handler();

        Manage_Data_Transmission();
        Handle_Transmit();
//        SD_FDRI();
        Decide_Mode();

    }
}

void Init(){
    Globals.Sat_Avoid_Mode = 0x00;
    Globals.Log_Packet_Seq_Counter = 0;Globals.Indication_Flags = 0;
    Globals.Flash_SPI_Tries_Limit = 5;Globals.Current_SD = MSS_SPI_SLAVE_1;
    Globals.Non_Response_Count_Limit = 20;


    Globals.Transmit_Completed_SBand = 0;
    Globals.Transmit_Helper.CMD_Seq_Count = 0;
    Globals.Transmit_Helper.Prev_CMD_Seq_Count = 0;
    Globals.Transmit_Helper.Response_Length = 0;
    Globals.Transmit_Helper.Response_Read = 0;

    int i =  RTC_Enable();
    if (i) {
    	Globals.Transmit_Completed_SBand = 1;
    }
    Global_Init_GPIOs();
    Flash_Init();

//   Load_Factory_Value();
//    statusG = Save_Parameter_Table();
    Load_Parameter_Table();
    Globals.Boot_Up_Counter++;
    Globals.Indication_Flags |= SAVE_PARAMETER_MAP_FLAG;

    CMD_Handle_Init();
    ADCS_init();
    CIP_Init_Comm();
    UHF_init();
    DAXSS_init();
    SBAND_Init_Comm();
    PWR_Init_Comm();
    //TODO: Test second SD_Card slot and get it working.
    // tested first slot with 128GB card, works
    // tested second slot with 128GB, doesn't
    // 16GB card untested in both slots of CDH v2.1
//    Globals.Current_SD = SD_Select_Init();

    if(Globals.Current_SD == 0xff){
          /* TODO: Log the error that none of the SD card is working, the indication flags has been set accordingly */
    }

}

void RTC_Sync_Timer_Hanlder(){
  if(Utils_Handle_Timer32_Started(&Globals.RTC_Sync_Timer)){
    Globals.Indication_Flags |= UPDATE_RTC_GPS;
  }
}

void Last_Command_Timer_Handler(){
    if(Utils_Handle_Timer32(&Globals.Last_Command_Timer,  LAST_COMMAND_TIMER_STARTED_FLAG)){
        Make_Log_packet("No command received, restarting", sizeof("No command received, restarting"));
//        SC_Restart();
    }
}

void PSLV_Wait_Timer_Handler(){
    if((Globals.Deps_Wait_Tumb_Flag & PSLV_WAIT_FLAG) > 0){
        if(Utils_Handle_Timer32(&Globals.PSLV_Wait_Timer, PSLV_WAIT_TIMER_STARTED_FLAG)){
            Globals.Deps_Wait_Tumb_Flag &= (~PSLV_WAIT_FLAG);
            Globals.Indication_Flags |= SAVE_PARAMETER_MAP_FLAG;    /* Save parameter map flag is set */
        }
    }
}

void Deployment_Timer_Handler(){
    if(((Globals.Deps_Wait_Tumb_Flag & PSLV_WAIT_FLAG) == 0) && ((Globals.Deps_Wait_Tumb_Flag & (SP1_DEPLOYMENT_FLAG | SP2_DEPLOYMENT_FLAG | ANT_DEPLOYMENT_FLAG)) > 0)){

        if((Globals.Timers_Started_Flag & DEPLOYMENT_WAIT_TIMER_STARTED_FLAG) == 0){
            Globals.Timers_Started_Flag |= DEPLOYMENT_WAIT_TIMER_STARTED_FLAG;
            Globals.Deployment_Wait_Timer.Start = RTC_Get_Value32();
            PWR_Switch(GPIO_DEP_SP1_Mask | GPIO_DEP_SP2_Mask | GPIO_DEP_ANT_Mask, PWR_SWITCH_OFF);
            return;
        }

        if(Utils_Handle_Timer32_Started(&Globals.Deployment_Wait_Timer)){   /* 30 minutes */
            if((Globals.Timers_Started_Flag & DEPLOYMENT_DURATION_TIMER_STARTED_FLAG) > 0){
                if(Utils_Handle_Timer16_Started(&Globals.Deployment_Duration_Timer)){    /* 60 seconds */
                    Globals.Deployment_Wait_Timer.Start = RTC_Get_Value32();
                    PWR_Switch(GPIO_DEP_SP1_Mask |GPIO_DEP_SP2_Mask | GPIO_DEP_ANT_Mask, PWR_SWITCH_OFF);
                    Globals.Timers_Started_Flag &= ~DEPLOYMENT_DURATION_TIMER_STARTED_FLAG;
                }
                return;
            }
            Globals.Deployment_Duration_Timer.Start = RTC_Get_Value16();

            uint8_t state = (Globals.Deps_Wait_Tumb_Flag & SP1_DEPLOYMENT_FLAG) > 0 ? PWR_SWITCH_ON : PWR_SWITCH_OFF;
            PWR_Switch(GPIO_DEP_SP1_Mask, state);

            state = (Globals.Deps_Wait_Tumb_Flag & SP2_DEPLOYMENT_FLAG) > 0 ? PWR_SWITCH_ON : PWR_SWITCH_OFF;
            PWR_Switch(GPIO_DEP_SP1_Mask, state);

            state = (Globals.Deps_Wait_Tumb_Flag & ANT_DEPLOYMENT_FLAG) > 0 ? PWR_SWITCH_ON : PWR_SWITCH_OFF;
            PWR_Switch(GPIO_DEP_SP1_Mask, state);

            Globals.Timers_Started_Flag |= DEPLOYMENT_DURATION_TIMER_STARTED_FLAG;
        }
    }
}


void HK_Timer_Handler(){
    if(Utils_Handle_Timer32(&Globals.HK_Timer, HK_TIMER_STARTED_FLAG)){
//        Store_HK_Data();
    }
}

void Store_HK_Data(){
  uint32_t * write_addr = &Globals.HK_Write_Start;
  uint8_t to_write[sizeof(HK_pack)+SIZEOF_SYNC_WORD];
  memcpy(to_write, (const void * restrict) SBAND_SYNC_WORD, SIZEOF_SYNC_WORD);
  memcpy(&to_write[SIZEOF_SYNC_WORD], &HK_pack, sizeof(HK_pack));
  uint8_t i = 0, tries = 0;
  //try up to 4 times
  while((i < (*write_addr + 1)) && (tries < 4)) {
    i = SD_Write_Data(to_write, sizeof(HK_pack) + SIZEOF_SYNC_WORD, *write_addr, Globals.Current_SD);
    tries++;
  }
  if (tries != 4) {
    //update Write_Start if successful
    *write_addr = i;
  }
}

void Beacon_Timer_Handler(){
    if(Utils_Handle_Timer32(&Globals.Beac_Timer, BEAC_TIMER_STARTED_FLAG)){
        Beacon_pack.CDH_Primary_Info = (Globals.Sat_Curr_Mode  & 0x07);
        Beacon_pack.CDH_Primary_Info |= (((Globals.Indication_Flags & IS_ECLIPSE) >> 4) & 0x80); /* The solar panel threshold is to be updated*/
        Beacon_pack.CDH_Primary_Info |= !(MSS_GPIO_get_outputs() & GPIO_EN_BUS_TRAN_Mask) << 4;
        Beacon_pack.CDH_Subsystem_ON_Stat = PWR_Update_SW_Data();
        Beacon_pack.CDH_Last_CMD_APID = Globals.Last_CMD_Rec.apid;
        Beacon_pack.CDH_Last_CMD_Option1 = Globals.Last_CMD_Rec.option1;
        Beacon_pack.CDH_Last_CMD_Option2 = Globals.Last_CMD_Rec.option2;

        Beacon_pack.CDH_Indication_Flags = Globals.Indication_Flags;

        Beacon_pack.CDH_ADCS_Read_start = Globals.ADCS_Read_Start;
        Beacon_pack.CDH_Beacon_Read_start = Globals.Beacon_Read_Start;
        Beacon_pack.CDH_HK_Read_start = Globals.HK_Read_Start;
        Beacon_pack.CDH_Log_Read_start = Globals.Log_Read_Start;
        Beacon_pack.CDH_SciC_Read_start = Globals.SciC_Read_Start;
        Beacon_pack.CDH_SciD_Read_start = Globals.SciD_Read_Start;

        Beacon_pack.CDH_ADCS_Write_start = Globals.ADCS_Write_Start;
        Beacon_pack.CDH_Beacon_Write_start = Globals.Beacon_Write_Start;
        Beacon_pack.CDH_HK_Write_start = Globals.HK_Write_Start;
        Beacon_pack.CDH_Log_Write_start = Globals.Log_Write_Start;
        Beacon_pack.CDH_SciC_Write_start = Globals.SciC_Write_Start;
        Beacon_pack.CDH_SciD_Write_start = Globals.SciD_Write_Start;


        uint32_t Curr = RTC_Get_Value32();
        /* Taking care of timer overflow */
        if (Curr < Globals.Last_Command_Timer.Start){
            Curr += (0xffffffff - Globals.Last_Command_Timer.Start);
        }else{
            Curr -= Globals.Last_Command_Timer.Start;
        }
        Beacon_pack.CDH_Last_CMD_Timer = Curr;

        CCSDS_Pack( BEACON_PACKET_APID, 0xC0, Globals.Beacon_Packet_Seq_Counter, (struct CCSDS_Header *)&(Beacon_pack.beac_head), sizeof(Beacon_pack));
        CCSDS_Fletcher_16((uint8_t *)(&Beacon_pack), sizeof(Beacon_pack) - 2);
        Globals.Beacon_Packet_Seq_Counter++;

        Store_Beacon_Data();

    }
}

void Store_Beacon_Data(){
  if (Globals.Current_SD == 0xff) {
	  return;
  }
  uint32_t * write_addr = &Globals.Beacon_Write_Start;
  uint16_t sync = SBAND_SYNC_WORD;
  uint16_t * sync_ptr = &sync;
  uint8_t to_write[sizeof(Beacon_pack)+SIZEOF_SYNC_WORD];
  memcpy(to_write, (uint8_t *)sync_ptr, SIZEOF_SYNC_WORD);
  memcpy(&to_write[SIZEOF_SYNC_WORD], &Beacon_pack, sizeof(Beacon_pack));
  uint32_t i = 0;
  uint8_t tries = 0;
  //try up to 4 times
  while((i < (*write_addr + 1)) && (tries < 4)) {
    i = SD_Write_Data(to_write, sizeof(Beacon_pack) + SIZEOF_SYNC_WORD, *write_addr, Globals.Current_SD);
    tries++;
  }
  if (tries < 4) {
    //update Write_Start if successful
    *write_addr = (i <= Globals.Beacon_Sector_End) ? i : Globals.Beacon_Sector_Start;
    //TODO: figure out when/how often to update Write_Start flag in flash -- being changed every second
    // how about every time we transmit beacon packet, we update parameter table.
//    if (Globals.Beacon_Packet_Seq_Counter % Beacon_Write_Start_Update_Cnt == 0) {
//    Globals.Indication_Flags |= SAVE_PARAMETER_MAP_FLAG;
//    }
  }
  else {
	  Globals.Current_SD = 0xff;
	  return;
  }

}

void Beacon_Transmit_Timer_Handler(){
    if((Globals.Deps_Wait_Tumb_Flag & PSLV_WAIT_FLAG) == 0){
        if(Utils_Handle_Timer32(&Globals.Beac_Trans_Timer, BEAC_TRANS_TIMER_STARTED_FLAG)){
          Globals.Indication_Flags |= REQ_BEACON_TRANSMIT;
            if((Globals.Indication_Flags & AUTO_SBAND_BEACON_TRANS) > 0){
                 // Transmit the latest beacon over SBand
            }
        }
    }
}

void Watchdog_Timer_Handler(){
    if(Utils_Handle_Timer16(&Globals.Watchdog_Signal_Timer, WATCHDOG_SIGNAL_TIMER_FLAG)){
        Watchdog_Pet();
    }
}

void Watchdog_Pet() {
	uint32_t k = (MSS_GPIO_get_outputs() & GPIO_RESET_IC_Mask);
	//toggle k
	k = k == 0;
	MSS_GPIO_set_output(GPIO_RESET_IC, k);
}

void Make_Log_packet(uint8_t *  msg, uint8_t len){
   uint8_t bus_transceiver_state = ((MSS_GPIO_get_outputs() & GPIO_EN_BUS_TRAN) >> 8);
   Log_pack.CDH_Primary_Info = Globals.Sat_Curr_Mode | bus_transceiver_state;
   Log_pack.Sub_System_Data_Valid_Flags = Beacon_pack.CDH_Sub_System_Data_Valid_Flags;
   uint8_t i=0;
   memcpy(Log_pack.Message, msg, len);
   memset(&Log_pack.Message[len], 0, 50-len);

   CCSDS_Pack( LOG_PACKET_APID, 0xC0, Globals.Log_Packet_Seq_Counter, &(Log_pack.log_head), sizeof(Log_pack));
   CCSDS_Fletcher_16((uint8_t *)(&Log_pack), sizeof(Log_pack) - 2);
   Globals.Log_Packet_Seq_Counter++;
}

void Make_Subsystem_Reponse_Packet(){
  Subsys_Response_pack.Bat_SOC = Beacon_pack.EPS_Bat_SOC;
  Subsys_Response_pack.CDH_Primary_Info = Beacon_pack.CDH_Primary_Info;
  Subsys_Response_pack.Response_valid = 1;

  CCSDS_Pack( SUBSYSTEM_RESPSONSE_PACKET_APID, 0xC0, Globals.Subsys_Response_Packet_Seq_Counter, &(Subsys_Response_pack.subsys_resp_head), sizeof(Subsys_Response_pack));
  CCSDS_Fletcher_16((uint8_t *)(&Subsys_Response_pack), sizeof(Subsys_Response_pack) - 2);
  Globals.Subsys_Response_Packet_Seq_Counter++;
}

void Decide_Mode(){
    uint16_t tmp_Sci_Char_Threshold = Globals.SciD_Char_Threshold < Globals.SciC_Char_Threshold ? Globals.SciD_Char_Threshold : Globals.SciD_Char_Threshold;

    if(Beacon_pack.EPS_Bat_SOC <= Globals.Safe_Phoe_Threshold){
        Globals.Sat_Curr_Mode = SC_PHOENIX_MODE;
    }
    else if( Globals.Phoe_Safe_Threshold < Beacon_pack.EPS_Bat_SOC && Beacon_pack.EPS_Bat_SOC <= Globals.Char_Safe_Threshold){
        Globals.Sat_Curr_Mode = SC_SAFE_MODE;
    }
    else if( Globals.Safe_Char_Threshold < Beacon_pack.EPS_Bat_SOC && Beacon_pack.EPS_Bat_SOC <= tmp_Sci_Char_Threshold){
        Globals.Sat_Curr_Mode = SC_CHARGING_MODE;
    }else{ // here we are checking if the SOC is more than the minimum of two threshold
        if(Globals.Indication_Flags & IS_ECLIPSE){
            if( Beacon_pack.EPS_Bat_SOC <= Globals.SciC_Char_Threshold){
                 Globals.Sat_Curr_Mode = SC_CHARGING_MODE;
            }
            else if( Globals.SciC_Char_Threshold < Beacon_pack.EPS_Bat_SOC && Beacon_pack.EPS_Bat_SOC <= Globals.Char_SciC_Threshold){
                if(Globals.Sat_Curr_Mode == SC_SCID_MODE)
                     Globals.Sat_Curr_Mode = SC_CHARGING_MODE;
            }
            else if( Globals.Char_SciC_Threshold < Beacon_pack.EPS_Bat_SOC && Beacon_pack.EPS_Bat_SOC <= 100){
                if(Globals.Sat_Curr_Mode == SC_SCID_MODE)
                  Globals.Sat_Curr_Mode = SC_CHARGING_MODE;
                 else
                   Globals.Sat_Curr_Mode = SC_SCID_MODE;
           }
        }else{
            if( Beacon_pack.EPS_Bat_SOC <= Globals.SciD_Char_Threshold){
                Globals.Sat_Curr_Mode = SC_CHARGING_MODE;
            }
            else if( Globals.SciD_Char_Threshold < Beacon_pack.EPS_Bat_SOC && Beacon_pack.EPS_Bat_SOC <= Globals.Char_SciD_Threshold){
                 if(Globals.Sat_Curr_Mode == SC_SCIC_MODE)
                     Globals.Sat_Curr_Mode = SC_CHARGING_MODE;
            }
            else if( Globals.Char_SciD_Threshold < Beacon_pack.EPS_Bat_SOC && Beacon_pack.EPS_Bat_SOC <= 100){
                 if(Globals.Sat_Curr_Mode == SC_SCIC_MODE)
                     Globals.Sat_Curr_Mode = SC_CHARGING_MODE;
                else
                     Globals.Sat_Curr_Mode = SC_SCIC_MODE;
            }
        }
    }


    if((Globals.CMD_Persistant_Flags & FORCE_MODE_FLAG) > 0){
        Globals.Sat_Curr_Mode = Globals.CMD_Forced_Mode;
        return;
    }
    if((Globals.Sat_Avoid_Mode & SC_AVOID_SAFE) > 0){
        Globals.Sat_Curr_Mode = SC_PHOENIX_MODE;
        return;
    }
    if(Globals.Sat_Avoid_Mode & SC_AVOID_CHARGING > 0){
        if(!(Globals.Sat_Curr_Mode == SC_SAFE_MODE || Globals.Sat_Curr_Mode == SC_PHOENIX_MODE)){
            Globals.Sat_Curr_Mode = SC_SAFE_MODE;
        }
        return;
    }
    if(Globals.Sat_Avoid_Mode & SC_AVOID_SCIC > 0){
        if(Globals.Sat_Curr_Mode == SC_SCIC_MODE){
            Globals.Sat_Curr_Mode = SC_CHARGING_MODE;
        }
        return;
    }
    if(Globals.Sat_Avoid_Mode & SC_AVOID_SCID > 0){
        if(Globals.Sat_Curr_Mode == SC_SCID_MODE){
            Globals.Sat_Curr_Mode = SC_CHARGING_MODE;
        }
        return;
    }
}

void SC_Restart(){
   uint8_t i = 0, j = 0;
   for(i = 0; i < 10; i++){
       j = 0;
       MSS_GPIO_set_output(GPIO_RESET_IC, 0);
       while(j < SC_REBOOT_SIGNAL_DELAY){
           j++;
       }
       MSS_GPIO_set_output(GPIO_RESET_IC, 1);
   }
}

void Handle_Power_Supply(){
    switch(Globals.Sat_Curr_Mode){
        case SC_PHOENIX_MODE:
              PWR_Switch(GPIO_DSW0_DAXSS_Mask | GPIO_DSW1_CIP_Mask | GPIO_DSW2_ADCS_Mask | GPIO_DSW3_Sband_Mask | GPIO_DSW4_Bat_heat_Mask, PWR_SWITCH_OFF);
            Beacon_pack.CDH_Sub_System_Data_Valid_Flags &= ~(ADCS_DATA_VALID_FLAG | SBAND_DATA_VALID_FLAG | CIP_DATA_VALID_FLAG | DAXSS_DATA_VALID_FLAG);
            Globals.Timers_Started_Flag &= ~ADCS_BOOT_WAIT_TIMER_STARTED;
            break;
        case SC_SAFE_MODE:
              PWR_Switch(GPIO_DSW0_DAXSS_Mask | GPIO_DSW1_CIP_Mask | GPIO_DSW3_Sband_Mask , PWR_SWITCH_OFF);
              PWR_Switch(GPIO_DSW2_ADCS_Mask, PWR_SWITCH_ON);

            Beacon_pack.CDH_Sub_System_Data_Valid_Flags &= ~(SBAND_DATA_VALID_FLAG | CIP_DATA_VALID_FLAG | DAXSS_DATA_VALID_FLAG);
            break;

        case SC_CHARGING_MODE:
              PWR_Switch(GPIO_DSW0_DAXSS_Mask | GPIO_DSW1_CIP_Mask, PWR_SWITCH_OFF);
              PWR_Switch(GPIO_DSW2_ADCS_Mask | GPIO_DSW3_Sband_Mask, PWR_SWITCH_ON);

            Beacon_pack.CDH_Sub_System_Data_Valid_Flags &= ~(CIP_DATA_VALID_FLAG | DAXSS_DATA_VALID_FLAG);
            break;

        case SC_SCIC_MODE:
              PWR_Switch(GPIO_DSW0_DAXSS_Mask | GPIO_DSW4_Bat_heat_Mask, PWR_SWITCH_OFF);
              PWR_Switch(GPIO_DSW1_CIP_Mask | GPIO_DSW2_ADCS | GPIO_DSW3_Sband_Mask, PWR_SWITCH_ON);

            Beacon_pack.CDH_Sub_System_Data_Valid_Flags &= ~(DAXSS_DATA_VALID_FLAG);
            break;

        case SC_SCID_MODE:
              PWR_Switch(GPIO_DSW1_CIP_Mask , PWR_SWITCH_OFF);
              PWR_Switch(GPIO_DSW0_DAXSS_Mask | GPIO_DSW2_ADCS | GPIO_DSW3_Sband_Mask, PWR_SWITCH_ON);
            Beacon_pack.CDH_Sub_System_Data_Valid_Flags &= ~(CIP_DATA_VALID_FLAG);
            break;
    }
}

void Manage_Data_Transmission(){
    uint32_t transmission_mask = UHF_TRANSMIT_ENABLE;
    if((Globals.Indication_Flags & TRANSMIT_BAND) > 0){
      transmission_mask = SBAND_TRANSMIT_ENABLE;
    }
    if(Globals.Next_Transmit.Transmit_Buffer_Index != Globals.Current_Transmit.Transmit_Buffer_Index){
        /* Taking care of second buffer transmission */
        if((Globals.Indication_Flags & transmission_mask) == 0){
            Globals.Current_Transmit.Transmit_Buffer_Index = Globals.Next_Transmit.Transmit_Buffer_Index;
            Globals.Current_Transmit.Transmit_Length = Globals.Next_Transmit.Transmit_Length;
            Globals.Current_Transmit.Total_Transmit_Length = Globals.Next_Transmit.Total_Transmit_Length;
            Globals.Current_Transmit.Transmit_Offset = Globals.Next_Transmit.Transmit_Offset;
            Globals.Indication_Flags |= transmission_mask;
            Globals.Transmit_Completed_UHF = 0;
            #ifdef ENABLE_UART0_COMMAND
                MSS_UART_polled_tx(CMD_UART, &Transmit_MSG[Globals.Current_Transmit.Transmit_Buffer_Index][Globals.Current_Transmit.Transmit_Offset], Globals.Current_Transmit.Transmit_Length);
            #endif
        }
    }

    if((Globals.Indication_Flags & REQ_SD_DATA_TRANSMIT) > 0){
      // if the transmission band is busy (i.e. ENABLE bit is set) AND both Transmit buffers are full, return. We can't do anything.
      if ((Globals.Indication_Flags & transmission_mask) && (Globals.Next_Transmit.Transmit_Buffer_Index != Globals.Current_Transmit.Transmit_Buffer_Index)) {
        return;
      }
      //At this point we know that EITHER the transmission band is idle, or we can load the next buffer with data.
      uint16_t packet_size, total_size;
      Globals.Current_Transmit.Total_Transmit_Length = Transmission_Total_Length;
      Globals.Next_Transmit.Total_Transmit_Length = Transmission_Total_Length;

      if((Globals.Transmit_Data_Flags & SCID_DATA_FLAG) >= SCID_DATA_FLAG){
		  total_size = Globals.SciD_Write_Start - Globals.SciD_Read_Start;
		  packet_size = SCID_PACKET_SIZE;
      }
      else if((Globals.Transmit_Data_Flags & SCIC_DATA_FLAG) >= SCIC_DATA_FLAG){
		  total_size = Globals.SciC_Write_Start - Globals.SciC_Read_Start;
		  packet_size = SCIC_PACKET_SIZE;
      }
      else if((Globals.Transmit_Data_Flags & ADCS_DATA_FLAG) >= ADCS_DATA_FLAG){
		total_size = Globals.ADCS_Write_Start - Globals.ADCS_Read_Start;
		//TODO: test current packet length
		//Size has been set to the largest ADCS packet, b/c Hydra can handle it.
		packet_size = ADCS_TM_PACKET_5_SIZE;
      }
      else if((Globals.Transmit_Data_Flags & LOG_DATA_FLAG) >= LOG_DATA_FLAG){
		total_size = Globals.Log_Write_Start - Globals.Log_Read_Start;
		packet_size = LOG_PACKET_SIZE;
      }
      else if((Globals.Transmit_Data_Flags & HK_DATA_FLAG) >= HK_DATA_FLAG){
		total_size = Globals.HK_Write_Start - Globals.HK_Read_Start;
		packet_size = HK_PACKET_SIZE;
      }
      else if((Globals.Transmit_Data_Flags & BEACON_DATA_FLAG) >= BEACON_DATA_FLAG){
		total_size = Globals.Beacon_Write_Start - Globals.Beacon_Read_Start;
		packet_size = BEACON_PACKET_SIZE;
      }
      uint8_t offset = 2;
      if((Globals.Indication_Flags & TRANSMIT_BAND) != 0){
		  offset = 0;
		  packet_size = SD_CARD_SINGLE_BLOCK_SIZE;
      }

      if((Globals.Indication_Flags & transmission_mask) == 0){
		/* The UHF/SBAND is not busy with any transmission */

		memcpy(Transmit_MSG[Globals.Current_Transmit.Transmit_Buffer_Index], &SD_Card_Transmit_Buffer[offset], packet_size);
		Globals.Current_Transmit.Transmit_Length = packet_size;
		Globals.Current_Transmit.Total_Transmit_Length = total_size;
		Globals.Indication_Flags |= transmission_mask;
		Globals.Current_Transmit.Transmit_Offset = 0;
		#ifdef ENABLE_UART0_COMMAND
		MSS_UART_polled_tx(CMD_UART, &Transmit_MSG[Globals.Current_Transmit.Transmit_Buffer_Index][Globals.Current_Transmit.Transmit_Offset], Globals.Current_Transmit.Transmit_Length);
		#endif
      }else{
        /* The second buffer is free to use */
        ++Globals.Next_Transmit.Transmit_Buffer_Index;
        Globals.Next_Transmit.Transmit_Buffer_Index %= 2;
        memcpy(Transmit_MSG[Globals.Next_Transmit.Transmit_Buffer_Index], &SD_Card_Transmit_Buffer[offset], packet_size);
        Globals.Next_Transmit.Transmit_Length = packet_size;
        Globals.Next_Transmit.Total_Transmit_Length = total_size;
        Globals.Next_Transmit.Transmit_Offset= 0;
      }
      Globals.Indication_Flags &= ~REQ_SD_DATA_TRANSMIT;
      return;
    }

    if((Globals.Indication_Flags & REQ_GLOBAL_TRANSMIT)){
        switch(Globals.Transmit_Helper.CMD_Seq_Count){
            case TRANS_HELPER_GLOBAL_TRANS1:
                if(((Globals.Indication_Flags & transmission_mask) == 0) || (Globals.Next_Transmit.Transmit_Buffer_Index == Globals.Current_Transmit.Transmit_Buffer_Index)){
                    Global_packet_Full_t p1;
                    memcpy(p1.data, (uint8_t *)&Globals, sizeof(p1.data));
                    CCSDS_Pack( GLOBAL_PACKET_APID_1, 0xC0, Globals.Globals_Table_Packet_Seq_Counter, &(p1.ccsds_head), sizeof(p1));
                    CCSDS_Fletcher_16((uint8_t *)(&p1), sizeof(p1) - 2);
                    if((Globals.Indication_Flags & transmission_mask) == 0){
                        /* The transmitter is free */
                        memcpy(Transmit_MSG[Globals.Current_Transmit.Transmit_Buffer_Index], (uint8_t *)&p1, sizeof(p1));    /* Transferring the first packet to the transmit buffer */
                        Globals.Current_Transmit.Transmit_Length = sizeof(p1);
                        Globals.Indication_Flags |= transmission_mask;
                        Globals.Transmit_Completed_UHF = 0;
                        Globals.Current_Transmit.Transmit_Offset = 0;
                        Globals.Transmit_Helper.Response_Length = Globals.Current_Transmit.Transmit_Buffer_Index;
                        #ifdef ENABLE_UART0_COMMAND
                            MSS_UART_polled_tx(CMD_UART, &Transmit_MSG[Globals.Current_Transmit.Transmit_Buffer_Index][Globals.Current_Transmit.Transmit_Offset], Globals.Current_Transmit.Transmit_Length);
                        #endif
                    }else{
                        ++Globals.Next_Transmit.Transmit_Buffer_Index;
                        Globals.Next_Transmit.Transmit_Buffer_Index %= 2;
                        Globals.Next_Transmit.Transmit_Length= sizeof(p1);
                        Globals.Next_Transmit.Transmit_Offset = 0;
                        memcpy(Transmit_MSG[Globals.Next_Transmit.Transmit_Buffer_Index], (uint8_t *)&p1, sizeof(p1));   /* Transferring the first packet to the transmit buffer */
                        Globals.Transmit_Helper.Response_Length = Globals.Next_Transmit.Transmit_Buffer_Index;
                    }
                    Globals.Transmit_Helper.CMD_Seq_Count = TRANS_HELPER_GLOBAL_TRANS2;
                }else{
                    /* No buffer is free */
                }
                break;

            case TRANS_HELPER_GLOBAL_TRANS2:
                if(((Globals.Indication_Flags & transmission_mask) == 0) || (Globals.Next_Transmit.Transmit_Buffer_Index == Globals.Current_Transmit.Transmit_Buffer_Index)){
                    Global_packet_Full_t p1;
                    memcpy(p1.data, &(((uint8_t *)&Globals)[sizeof(p1.data)]), sizeof(p1.data));
                    CCSDS_Pack( GLOBAL_PACKET_APID_2, 0xC0, Globals.Globals_Table_Packet_Seq_Counter, &(p1.ccsds_head), sizeof(p1));
                    CCSDS_Fletcher_16((uint8_t *)(&p1), sizeof(p1) - 2);
                    if((Globals.Indication_Flags & transmission_mask) == 0){
                        /* The transmitter is free */
                        memcpy(Transmit_MSG[Globals.Current_Transmit.Transmit_Buffer_Index], (uint8_t *)&p1, sizeof(p1));    /* Transferring the first packet to the transmit buffer */
                        Globals.Current_Transmit.Transmit_Length = sizeof(p1);
                        Globals.Indication_Flags |= transmission_mask;
                        Globals.Transmit_Completed_UHF = 0;
                        Globals.Current_Transmit.Transmit_Offset = 0;
                        Globals.Transmit_Helper.Response_Length = Globals.Current_Transmit.Transmit_Buffer_Index;
                        #ifdef ENABLE_UART0_COMMAND
                            MSS_UART_polled_tx(CMD_UART, &Transmit_MSG[Globals.Current_Transmit.Transmit_Buffer_Index][Globals.Current_Transmit.Transmit_Offset], Globals.Current_Transmit.Transmit_Length);
                        #endif
                    }else{
                        ++Globals.Next_Transmit.Transmit_Buffer_Index;
                        Globals.Next_Transmit.Transmit_Buffer_Index %= 2;
                        Globals.Next_Transmit.Transmit_Length= sizeof(p1);
                        Globals.Next_Transmit.Transmit_Offset = 0;
                        memcpy(Transmit_MSG[Globals.Next_Transmit.Transmit_Buffer_Index], (uint8_t *)&p1, sizeof(p1));   /* Transferring the first packet to the transmit buffer */
                        Globals.Transmit_Helper.Response_Length = Globals.Next_Transmit.Transmit_Buffer_Index;
                    }
                    Globals.Transmit_Helper.CMD_Seq_Count = TRANS_HELPER_GLOBAL_TRANS3;
                }
                break;

            case TRANS_HELPER_GLOBAL_TRANS3:
                if(((Globals.Indication_Flags & transmission_mask) == 0) || (Globals.Next_Transmit.Transmit_Buffer_Index == Globals.Current_Transmit.Transmit_Buffer_Index)){

                    Global_packet_Last_t p1;
                    memcpy(p1.data, &(((uint8_t *)&Globals)[2*CCSDS_MAX_DATA_SIZE]), sizeof(p1.data));
                    CCSDS_Pack( GLOBAL_PACKET_APID_3, 0xC0, Globals.Globals_Table_Packet_Seq_Counter, &(p1.global_head), sizeof(p1));
                    CCSDS_Fletcher_16((uint8_t *)(&p1), sizeof(p1) - 2);
                    if((Globals.Indication_Flags & transmission_mask) == 0){
                        /* The transmitter is free */
                        memcpy(Transmit_MSG[Globals.Current_Transmit.Transmit_Buffer_Index], (uint8_t *)&p1, sizeof(p1));    /* Transferring the first packet to the transmit buffer */
                        Globals.Current_Transmit.Transmit_Length = sizeof(p1);
                        Globals.Indication_Flags |= transmission_mask;
                        Globals.Transmit_Completed_UHF = 0;
                        Globals.Current_Transmit.Transmit_Offset = 0;
                        Globals.Transmit_Helper.Response_Length = Globals.Current_Transmit.Transmit_Buffer_Index;
                        #ifdef ENABLE_UART0_COMMAND
                            MSS_UART_polled_tx(CMD_UART, &Transmit_MSG[Globals.Current_Transmit.Transmit_Buffer_Index][Globals.Current_Transmit.Transmit_Offset], Globals.Current_Transmit.Transmit_Length);
                        #endif
                    }else{
                        ++Globals.Next_Transmit.Transmit_Buffer_Index;
                        Globals.Next_Transmit.Transmit_Buffer_Index %= 2;
                        Globals.Next_Transmit.Transmit_Length= sizeof(p1);
                        Globals.Next_Transmit.Transmit_Offset = 0;
                        memcpy(Transmit_MSG[Globals.Next_Transmit.Transmit_Buffer_Index], (uint8_t *)&p1, sizeof(p1));   /* Transferring the first packet to the transmit buffer */
                        Globals.Transmit_Helper.Response_Length = Globals.Next_Transmit.Transmit_Buffer_Index;
                    }
                    Globals.Indication_Flags &= ~REQ_GLOBAL_TRANSMIT;
                    Globals.Transmit_Helper.CMD_Seq_Count = 0x00;
                }
                break;
        }
        return;
    }

    if((Globals.Indication_Flags & REQ_PARAM_TRANSMIT)){
        Param_Table_t k;
        switch(Globals.Transmit_Helper.CMD_Seq_Count){
            case TRANS_HELPER_PARAM_READ:


                if(((Globals.Indication_Flags & transmission_mask) == 0) || (Globals.Next_Transmit.Transmit_Buffer_Index == Globals.Current_Transmit.Transmit_Buffer_Index)){

                    /* Get the parameter table filled only if any one of the buffer is free */

                    if(!Globals.Transmit_Helper.Response_Length){
                        Get_Filled_Array(&k);
                    }else{
                        if(Read_Parameter_Table(&k)){
                            Globals.Transmit_Helper.CMD_Seq_Count = TRANS_HELPER_PARAM_TRANS1;
                        }else{
                            /*TODO: Read operation failed. Log it and reset the helper's state. */
                            Globals.Indication_Flags &= ~REQ_PARAM_TRANSMIT;    /* Give up transmitting the Parameter table */
                            Globals.Transmit_Helper.CMD_Seq_Count = 0x00;   /* Reseting the transmit helper state machine to default starting point for other transmit operations*/

                            break;
                        }
                    }
                }else{
                    /* No buffer is free*/
                    Globals.Transmit_Helper.CMD_Seq_Count = TRANS_HELPER_PARAM_READ; /* Keeping the state machine to the initial state machine so that it will send the parameter table as soon as the busy flag is removed. */
                    break;
                }
                Param_table_packet1_t p1; Param_table_packet2_t p2;
                memcpy(p1.data, (uint8_t *)&k, sizeof(p1.data));    /* Filling the 1st packet with the data */
                CCSDS_Pack( PARAMETER_PACKET_APID_1, 0xC0, Globals.Parameter_Table_Packet_Seq_Counter, &(p1.ccsds_head), sizeof(p1));
                CCSDS_Fletcher_16((uint8_t *)(&p1), sizeof(p1) - 2);

                memcpy(p2.data, &(((uint8_t *)&k)[sizeof(p1.data)]), sizeof(p2.data));  /* Filling the 2nd packet with the data */
                CCSDS_Pack( PARAMETER_PACKET_APID_2, 0xC0, Globals.Parameter_Table_Packet_Seq_Counter, &(p2.param_head), sizeof(p2));
                CCSDS_Fletcher_16((uint8_t *)(&p2), sizeof(p2) - 2);
                Globals.Parameter_Table_Packet_Seq_Counter++;

                if((Globals.Indication_Flags & transmission_mask) == 0){
                    memcpy(Transmit_MSG[Globals.Current_Transmit.Transmit_Buffer_Index], (uint8_t *)&p1, sizeof(p1));    /* Transferring the first packet to the transmit buffer */
                    memcpy(&Transmit_MSG[Globals.Current_Transmit.Transmit_Buffer_Index][sizeof(p1)], (uint8_t *)&p2, sizeof(p2));   /* Stacking second packet to the transmit buffer */
                    Globals.Current_Transmit.Transmit_Length = sizeof(p1);
                    Globals.Indication_Flags |= transmission_mask;
                    Globals.Transmit_Completed_UHF = 0;
                    Globals.Current_Transmit.Transmit_Offset = 0;
                    Globals.Transmit_Helper.Response_Length = Globals.Current_Transmit.Transmit_Buffer_Index;

                    #ifdef ENABLE_UART0_COMMAND
                        MSS_UART_polled_tx(CMD_UART, &Transmit_MSG[Globals.Current_Transmit.Transmit_Buffer_Index][Globals.Current_Transmit.Transmit_Offset], Globals.Current_Transmit.Transmit_Length);
                    #endif
                }else{
                    if(Globals.Next_Transmit.Transmit_Buffer_Index == Globals.Current_Transmit.Transmit_Buffer_Index){
                        ++Globals.Next_Transmit.Transmit_Buffer_Index;
                        Globals.Next_Transmit.Transmit_Buffer_Index %= 2;
                        Globals.Next_Transmit.Transmit_Length= sizeof(p1);
                        Globals.Next_Transmit.Transmit_Offset = 0;
                        memcpy(Transmit_MSG[Globals.Next_Transmit.Transmit_Buffer_Index], (uint8_t *)&p1, sizeof(p1));   /* Transferring the first packet to the transmit buffer */
                        memcpy(&Transmit_MSG[Globals.Next_Transmit.Transmit_Buffer_Index][sizeof(p1)], (uint8_t *)&p2, sizeof(p2));  /* Stacking second packet to the transmit buffer */
                        Globals.Transmit_Helper.Response_Length = Globals.Next_Transmit.Transmit_Buffer_Index;
                    }
                }
                Globals.Current_Transmit.Total_Transmit_Length = sizeof(p1)+sizeof(p2);
                Globals.Next_Transmit.Total_Transmit_Length = Globals.Current_Transmit.Total_Transmit_Length;
                /* At this point the value of Globals.Transmit_Helper. Response_Length is not required hence it can be used for different purposes. */
                Globals.Transmit_Helper.CMD_Seq_Count = TRANS_HELPER_PARAM_TRANS1;
                break;

            case TRANS_HELPER_PARAM_TRANS1:
                if((Globals.Indication_Flags & transmission_mask) == 0){
                    Globals.Indication_Flags |= transmission_mask;
                    Globals.Current_Transmit.Transmit_Offset = Globals.Current_Transmit.Transmit_Length;
                    Globals.Current_Transmit.Transmit_Length = sizeof(Param_table_packet2_t);
                    Globals.Transmit_Helper.Response_Length = Globals.Current_Transmit.Transmit_Buffer_Index;
                    Globals.Transmit_Helper.CMD_Seq_Count = 0x00;
                    Globals.Indication_Flags &= ~REQ_PARAM_TRANSMIT;

                    #ifdef ENABLE_UART0_COMMAND
                    MSS_UART_polled_tx(CMD_UART, &Transmit_MSG[Globals.Current_Transmit.Transmit_Buffer_Index][Globals.Current_Transmit.Transmit_Offset], Globals.Current_Transmit.Transmit_Length);
                    #endif
                    break;
                }
                Globals.Transmit_Helper.CMD_Seq_Count = TRANS_HELPER_PARAM_TRANS1;
                break;

            default:
                Globals.Transmit_Helper.CMD_Seq_Count = TRANS_HELPER_PARAM_READ;
                break;
        }
        return;

    }

    if((Globals.Indication_Flags & REQ_SUBSYS_RESPONSE_TRANSMIT) > 0){
        if((Globals.Indication_Flags & transmission_mask) == 0){
            /* The UHF is not busy with any transmission */
            memcpy(Transmit_MSG[Globals.Current_Transmit.Transmit_Buffer_Index], (uint8_t *)&Subsys_Response_pack, sizeof(Subsys_Response_pack));

            Globals.Current_Transmit.Transmit_Length = sizeof(Subsys_Response_pack);
            Globals.Current_Transmit.Total_Transmit_Length = Globals.Current_Transmit.Transmit_Length;
            Globals.Indication_Flags |= transmission_mask;
            Globals.Transmit_Completed_UHF = 0;
            Globals.Current_Transmit.Transmit_Offset = 0;

            #ifdef ENABLE_UART0_COMMAND
            MSS_UART_polled_tx(CMD_UART, &Transmit_MSG[Globals.Current_Transmit.Transmit_Buffer_Index][Globals.Current_Transmit.Transmit_Offset], Globals.Current_Transmit.Transmit_Length);
            #endif
        }else{
            if(Globals.Next_Transmit.Transmit_Buffer_Index == Globals.Current_Transmit.Transmit_Buffer_Index){
                /* The second buffer is free to use */
                ++Globals.Next_Transmit.Transmit_Buffer_Index;
                Globals.Next_Transmit.Transmit_Buffer_Index %= 2;
                memcpy(Transmit_MSG[Globals.Next_Transmit.Transmit_Buffer_Index], (uint8_t *)&Subsys_Response_pack, sizeof(Subsys_Response_pack));
                Globals.Next_Transmit.Transmit_Length = sizeof(Subsys_Response_pack);
                Globals.Next_Transmit.Total_Transmit_Length = Globals.Next_Transmit.Transmit_Length;
                Globals.Next_Transmit.Transmit_Offset = 0;
            }else{
            /* The second buffer is full. The subsystem response packet will not be transmitted. */
            }
        }
        Globals.Indication_Flags &= ~REQ_SUBSYS_RESPONSE_TRANSMIT;
        /* Having return here implies that if the subsystem respones transmit request is present then
        * all other transmission requests below it gets ignored for the current loop and will be
        * serviced only when the beacon transmission is over.*/
        return;
    }

    if((Globals.Indication_Flags & REQ_BEACON_TRANSMIT) > 0){
        if((Globals.Indication_Flags & transmission_mask) == 0){
            /* The UHF is not busy with any transmission */
            memcpy(Transmit_MSG[Globals.Current_Transmit.Transmit_Buffer_Index], (uint8_t *)&Beacon_pack, sizeof(Beacon_pack));

            Globals.Current_Transmit.Transmit_Length = sizeof(Beacon_pack);
            Globals.Current_Transmit.Total_Transmit_Length = Globals.Current_Transmit.Transmit_Length;
            Globals.Indication_Flags |= transmission_mask;
            Globals.Transmit_Completed_UHF = 0;
            Globals.Current_Transmit.Transmit_Offset = 0;
            #ifdef ENABLE_UART0_COMMAND
                MSS_UART_polled_tx(CMD_UART, &Transmit_MSG[Globals.Current_Transmit.Transmit_Buffer_Index][Globals.Current_Transmit.Transmit_Offset], Globals.Current_Transmit.Transmit_Length);
            #endif
        }else{
            if(Globals.Next_Transmit.Transmit_Buffer_Index == Globals.Current_Transmit.Transmit_Buffer_Index){
                /* The second buffer is free to use */
                ++Globals.Next_Transmit.Transmit_Buffer_Index;
                Globals.Next_Transmit.Transmit_Buffer_Index %= 2;
                memcpy(Transmit_MSG[Globals.Next_Transmit.Transmit_Buffer_Index], (uint8_t *)&Beacon_pack, sizeof(Beacon_pack));
                Globals.Next_Transmit.Transmit_Length = sizeof(Beacon_pack);
                Globals.Next_Transmit.Total_Transmit_Length = Globals.Next_Transmit.Transmit_Length;
                Globals.Next_Transmit.Transmit_Offset= 0;
            }else{
                /* The second buffer is full. The beacon packet will not be transmitted. */
            }
        }
        Globals.Indication_Flags &= ~REQ_BEACON_TRANSMIT;
        /* Having return here implies that if the beacon transmit request is present then
         * all other transmission requests below it gets ignored for the current loop and will be
         * serviced only when the beacon transmission is over.*/
    return;
    }


}

void Handle_Transmit(){
    if((Globals.Indication_Flags & UHF_TRANSMIT_ENABLE) > 0){
        if(Globals.UHF_TX_Module_Sync.CMD_Seq_Count == UHF_TX_STATE_IDLE){
            if(Globals.Transmit_Completed_UHF == 0){
                Globals.UHF_TX_Module_Sync.CMD_Seq_Count = UHF_TX_STATE_TRANSFER_DATA;
                Globals.Transmit_Completed_UHF = 1;
            }else{
                Globals.Indication_Flags &= ~UHF_TRANSMIT_ENABLE;
                Globals.Transmit_Completed_UHF = 0;
            }
        }
        uint8_t tmp = UHF_TX_Transmit_Data(UHF_TX_ADDR, (uint8_t *)&ax_25_pack, sizeof(ax_25_pack), &Transmit_MSG[Globals.Current_Transmit.Transmit_Buffer_Index][Globals.Current_Transmit.Transmit_Offset], Globals.Current_Transmit.Transmit_Length);
        if(tmp == UHF_TX_ERROR_RETURN){
          /* TODO: lOG the error */
          Globals.Indication_Flags &= ~UHF_TRANSMIT_ENABLE;
          Globals.Indication_Flags &= ~REQ_SUBSYS_RESPONSE_TRANSMIT;
        }
    }

    if((Globals.Indication_Flags & SBAND_TRANSMIT_ENABLE) > 0){
        if(Globals.SBand_Module_Sync.CMD_Seq_Count == SBAND_STATE_IDLE){
            if(Globals.Transmit_Completed_SBand == 1){
                Globals.Indication_Flags &= ~SBAND_TRANSMIT_ENABLE;
            }else{
                Globals.SBand_Module_Sync.CMD_Seq_Count = SBAND_STATE_RESET;
                Globals.SBand_Module_Sync.Prev_CMD_Seq_Count = SBAND_STATE_RESET;
                Globals.Indication_Flags |= TRANSMIT_DATA_READY;
                Globals.Transmit_Completed_SBand = 1;
            }
        }
    }
}

void Utils_SPI_Custom_Setup(mss_spi_instance_t * this_spi, uint16_t frame_count){
    ASSERT((this_spi == &g_mss_spi0) || (this_spi == &g_mss_spi1));

    /* This function is only intended to be used with an SPI master. */
    ASSERT((this_spi->hw_reg->CONTROL & CTRL_MASTER_MASK) == CTRL_MASTER_MASK);

    /* Flush the Tx and Rx FIFOs. */
    this_spi->hw_reg->COMMAND |= (TX_FIFO_RESET_MASK | RX_FIFO_RESET_MASK);

    /* Set frame size and the frame count .*/
    this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
    this_spi->hw_reg->CONTROL = (this_spi->hw_reg->CONTROL & ~TXRXDFCOUNT_MASK) | ( (frame_count << TXRXDFCOUNT_SHIFT) & TXRXDFCOUNT_MASK);
    this_spi->hw_reg->TXRXDF_SIZE = MAX_FRAME_LENGTH;
    this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;

}


/* This function is suppose to be in Utils.c file but something is going wrong with it in when kept in the file
 * hence it is kept here.*/
uint16_t Utils_SPI_Transmit_Block(mss_spi_instance_t * this_spi, uint8_t * cmd_buffer, uint16_t cmd_byte_size){
    if(cmd_byte_size == 0)
        return 0;

    uint16_t transfer_idx = 0u;
    int16_t tx_idx;
    uint16_t c;
    uint32_t frame_count;
    uint32_t tx_fifo_empty;

    Utils_SPI_Custom_Setup(this_spi, cmd_byte_size);

    tx_idx = 0u;c = 0;
    /* Perform the remainder of the transfer by sending 4 bytes at a time.
     * This should ensure that no Rx overflow can happen in
     * case of an interrupt occurs during this function. */
    while(transfer_idx < cmd_byte_size)
    {

        tx_fifo_empty = this_spi->hw_reg->STATUS & TX_FIFO_EMPTY_MASK;
        if(TX_FIFO_EMPTY_MASK == tx_fifo_empty)
        {
            tx_idx = cmd_byte_size - transfer_idx;
            /* Send another 4 bytes. */
            if(tx_idx >= MAX_FRAME_LENGTH/8)
            {
                this_spi->hw_reg->TX_DATA = Utils_Buffer_to_32_ValueS_Big(&cmd_buffer[transfer_idx]);
                transfer_idx += 4;
            }
            else
            {
                this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
                this_spi->hw_reg->TXRXDF_SIZE = MSS_SPI_BLOCK_TRANSFER_FRAME_SIZE;
                this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;

                this_spi->hw_reg->TX_DATA = cmd_buffer[transfer_idx];
                ++transfer_idx;
            }
            c=0;
            continue;
        }
        c++;
        if(c > SPI_ESCAPE_LIMIT){
            break;
        }

    }
    return transfer_idx;

}

/* This function is suppose to be in Utils.c file but something is going wrong with it in when kept in the file
 * hence it is kept here.*/
uint16_t Utils_SPI_Receive_Block(mss_spi_instance_t * this_spi, uint8_t * rec_buffer, uint16_t rec_byte_size){
    if(rec_byte_size == 0)
        return 0;

    uint16_t transfer_idx = 0u;
    int16_t tx_idx;
    uint16_t rx_idx;
    uint16_t c;
    uint32_t frame_count;
    uint32_t rx_fifo_empty, tx_fifo_full;uint32_t rx_raw;
    int16_t transit = 0u;

    Utils_SPI_Custom_Setup(this_spi, rec_byte_size);

    tx_idx = 0u; c = 0; rx_idx = 0;uint8_t comp = RX_FIFO_SIZE;
    /* Perform the remainder of the transfer by sending 4 bytes at a time.
     * This should ensure that no Rx overflow can happen in
     * case of an interrupt occurs during this function. */
    while(transfer_idx < rec_byte_size)
    {

        rx_fifo_empty = this_spi->hw_reg->STATUS & RX_FIFO_EMPTY_MASK;
        if(0u == rx_fifo_empty)
        {
            /* Process received byte. */
            rx_raw = this_spi->hw_reg->RX_DATA;

            if(rx_idx < rec_byte_size)
            {
                frame_count = rec_byte_size - rx_idx;
                if(frame_count < RX_FIFO_SIZE){
                    rec_buffer[rx_idx] = rx_raw  & 0xff;
                    ++rx_idx;

                    transfer_idx++;
                }else{
                    rec_buffer[rx_idx] = (rx_raw >> 24) & 0xff;
                    ++rx_idx;
                    rec_buffer[rx_idx] = (rx_raw >> 16) & 0xff;
                    ++rx_idx;
                    rec_buffer[rx_idx] = (rx_raw >> 8) & 0xff;
                    ++rx_idx;
                    rec_buffer[rx_idx] = rx_raw & 0xff;
                    ++rx_idx;
                    comp  = RX_FIFO_SIZE;

                    transfer_idx+=4;
                }
                transit = 0;
            }

        }

        tx_fifo_full = this_spi->hw_reg->STATUS & TX_FIFO_FULL_MASK;
        if(0u == tx_fifo_full)
        {
            if(transit == 0)
            {
                if(tx_idx < rec_byte_size)
                {
                    frame_count = rec_byte_size - tx_idx;
                    if(frame_count < RX_FIFO_SIZE){
                        this_spi->hw_reg->CONTROL &= ~(uint32_t)CTRL_ENABLE_MASK;
                        this_spi->hw_reg->TXRXDF_SIZE = MSS_SPI_BLOCK_TRANSFER_FRAME_SIZE;
                        this_spi->hw_reg->CONTROL |= CTRL_ENABLE_MASK;
                        tx_idx++;
                    }else{
                        tx_idx+=4;
                    }
                    transit = 1;
                    this_spi->hw_reg->TX_DATA = 0x00u;
                }
            }
        }
    }
    return transfer_idx;

}
#endif
